<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Cyber Lap Race — 12 Themed Laps + MCQ Pit Stops</title>
  <style>
    :root{
      --bg:#070A12;
      --ink:#EAF0FF;
      --muted: rgba(234,240,255,0.72);
      --stroke: rgba(255,255,255,0.14);
      --shadow: rgba(0,0,0,0.40);

      --cyan:#5AE4FF;
      --green:#35F28C;
      --pink:#FF4D6D;
      --amber:#FFD166;
      --violet:#A78BFA;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:var(--ink);
      background:
        radial-gradient(1200px 780px at 18% 8%, rgba(90,228,255,0.18), transparent 55%),
        radial-gradient(1100px 760px at 78% 22%, rgba(53,242,140,0.12), transparent 58%),
        radial-gradient(1100px 760px at 50% 110%, rgba(255,77,109,0.10), transparent 58%),
        var(--bg);
      overflow:hidden;
    }
    .wrap{max-width:1200px;margin:0 auto;padding:12px}
    .card{
      border:1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.04));
      border-radius:18px;
      box-shadow: 0 18px 44px var(--shadow);
      overflow:hidden;
    }
    .topbar{
      display:flex; align-items:center; justify-content:space-between;
      padding: 12px 14px;
      border-bottom: 1px solid rgba(255,255,255,0.10);
      background: rgba(10,14,26,0.52);
      backdrop-filter: blur(6px);
      gap: 12px; flex-wrap:wrap;
    }
    .brand{ display:flex; align-items:center; gap:10px; min-width: 260px; }
    .logo{
      width:14px; height:14px; border-radius:50%;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.9), rgba(90,228,255,0.95) 55%, rgba(90,228,255,0.15));
      box-shadow: 0 0 18px rgba(90,228,255,0.60);
      flex:0 0 auto;
    }
    .title{ font-weight: 820; letter-spacing:0.2px; line-height:1.1; }
    .subtitle{ font-size: 12px; color: var(--muted); margin-top: 2px; }

    .pills{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; justify-content:flex-end; }
    .pill{
      display:flex; gap:8px; align-items:center;
      padding: 7px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      font-size: 12px;
      color: rgba(234,240,255,0.90);
      white-space:nowrap;
    }
    .pill b{ color: var(--ink); }
    .dot{
      width: 7px; height: 7px; border-radius: 50%;
      background: var(--cyan);
      box-shadow: 0 0 12px rgba(90,228,255,0.65);
    }

    .btnrow{ display:flex; gap:10px; flex-wrap:wrap; }
    button{
      appearance:none;
      border: 1px solid rgba(255,255,255,0.16);
      background: linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.05));
      color: var(--ink);
      border-radius: 12px;
      padding: 9px 12px;
      font-weight: 740;
      cursor:pointer;
      box-shadow: 0 10px 24px rgba(0,0,0,0.28);
      transition: transform .12s ease, border-color .12s ease;
      font-size: 12px;
    }
    button:hover{ transform: translateY(-1px); border-color: rgba(90,228,255,0.35); }
    button:active{ transform: translateY(0px) scale(0.99); }
    button.primary{
      border-color: rgba(90,228,255,0.50);
      background: linear-gradient(180deg, rgba(90,228,255,0.22), rgba(90,228,255,0.10));
    }

    .stage{
      position: relative;
      height: min(78vh, 720px);
      min-height: 420px;
      background:
        radial-gradient(1100px 760px at 50% 50%, rgba(255,255,255,0.06), transparent 60%),
        linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.06));
    }
    @media (max-width: 560px){
      .stage{ height: 74vh; min-height: 520px; }
      .subtitle{ display:none; }
    }
    canvas{ width:100%; height:100%; display:block; }

    .overlay{
      position:absolute; inset:0;
      display:none;
      align-items:center; justify-content:center;
      padding: 16px;
      background: rgba(0,0,0,0.52);
      backdrop-filter: blur(8px);
    }
    .overlay.show{ display:flex; }

    .panel{
      width: min(920px, 100%);
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.16);
      background: linear-gradient(180deg, rgba(10,14,26,0.92), rgba(10,14,26,0.78));
      box-shadow: 0 26px 60px rgba(0,0,0,0.55);
      overflow:hidden;
    }
    .phead{
      padding: 14px;
      border-bottom: 1px solid rgba(255,255,255,0.10);
      display:flex; align-items:flex-start; justify-content:space-between; gap:10px;
      background:
        radial-gradient(520px 240px at 20% 0%, rgba(90,228,255,0.14), transparent 60%),
        radial-gradient(520px 240px at 80% 0%, rgba(255,77,109,0.10), transparent 60%);
    }
    .phead .t{ font-weight: 860; letter-spacing:0.2px; }
    .phead .m{ font-size: 12px; color: var(--muted); margin-top: 3px; }
    .badgeP{
      padding: 7px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      font-size: 12px;
      white-space:nowrap;
    }
    .pbody{ padding: 14px; }

    .qtext{ font-size: 16px; line-height: 1.35; margin: 0 0 12px; color: rgba(234,240,255,0.95); }
    .opts{ display:grid; gap:10px; grid-template-columns: 1fr 1fr; }
    @media (max-width: 640px){ .opts{ grid-template-columns: 1fr; } }
    .opt{
      text-align:left;
      padding: 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.05);
      cursor:pointer;
      transition: transform .12s ease, border-color .12s ease, background .12s ease;
      min-height: 54px;
      display:flex; gap:10px; align-items:flex-start;
      user-select:none;
    }
    .opt:hover{ transform: translateY(-1px); border-color: rgba(90,228,255,0.35); }
    .badge{
      width: 26px; height: 26px; border-radius: 10px;
      display:grid; place-items:center;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.06);
      font-weight: 900;
      color: rgba(234,240,255,0.92);
      flex: 0 0 auto;
    }
    .opt.good{ border-color: rgba(53,242,140,0.55); background: rgba(53,242,140,0.12); }
    .opt.bad{ border-color: rgba(255,77,109,0.60); background: rgba(255,77,109,0.10); }

    .pfoot{
      padding: 12px 14px;
      border-top: 1px solid rgba(255,255,255,0.10);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      flex-wrap:wrap;
    }
    .small{ font-size: 12px; color: var(--muted); line-height: 1.45; }
    .feedback{
      font-size: 12px; color: var(--muted);
      max-width: 72ch;
      line-height: 1.35;
    }
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.05);
      color: rgba(234,240,255,0.86);
    }
    .hidden{ display:none !important; }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="card">
      <div class="topbar">
        <div class="brand">
          <span class="logo"></span>
          <div>
            <div class="title">Lap Circuit Race</div>
            <div class="subtitle">1 full lap → pit stop MCQ → next lap (12 laps, 12 different track looks)</div>
          </div>
        </div>

        <div class="pills">
          <div class="pill"><span class="dot"></span><b id="lapText">Lap 0/12</b></div>
          <div class="pill"><span class="dot" style="background:var(--green)"></span><b id="themeText">Theme 1/12</b></div>
          <div class="pill"><span class="dot" style="background:var(--amber)"></span><b id="stateText">Ready</b></div>
        </div>

        <div class="btnrow">
          <button class="primary" id="startBtn">Start</button>
          <button id="soundBtn" aria-pressed="false">Sound: Off</button>
          <button id="resetBtn">Reset</button>
        </div>
      </div>

      <div class="stage" id="stage">
        <canvas id="c"></canvas>

        <div class="overlay" id="overlay" aria-modal="true" role="dialog">
          <div class="panel">

            <div id="mcqPanel">
              <div class="phead">
                <div style="min-width:0">
                  <div class="t" id="qTitle">Checkpoint Question</div>
                  <div class="m" id="qMeta">Correct = next lap. Wrong = retry.</div>
                </div>
                <div class="badgeP" id="qLap">Lap 1/12</div>
              </div>

              <div class="pbody">
                <p class="qtext" id="qText">Question…</p>
                <div class="opts" id="opts"></div>
              </div>

              <div class="pfoot">
                <div class="small" id="hintText">Tip…</div>
                <div class="feedback" id="fbText"></div>
                <div class="small">Keys: <span class="kbd">A</span> <span class="kbd">B</span> <span class="kbd">C</span> <span class="kbd">D</span></div>
              </div>
            </div>

          </div>
        </div>
      </div><!-- stage -->
    </div>
  </div>

<script>
(() => {
  // ============================================================
  // QUESTIONS (12) — FIXED: correct option is NOT always A
  // Store correct answer as text, then shuffle options each time.
  // ============================================================
  const QUESTIONS_BASE = [
    {
      q:"CERT-In is primarily responsible for:",
      options:[
        "Responding to cyber incidents, vulnerability reporting, and promoting IT security practices",
        "Running state police station crime databases",
        "Issuing passports for cyber professionals",
        "Maintaining only a national email directory"
      ],
      correctText:"Responding to cyber incidents, vulnerability reporting, and promoting IT security practices",
      hint:"National incident response team.",
      fb:"CERT-In is India’s national agency for cyber incident response and advisories."
    },
    {
      q:"NCIIPC is associated with protecting:",
      options:[
        "Critical Information Infrastructure (CII)",
        "Only private banking passwords",
        "Only university LMS portals",
        "Only social media accounts"
      ],
      correctText:"Critical Information Infrastructure (CII)",
      hint:"Think: CII protection.",
      fb:"NCIIPC is the nodal body for protection of Critical Information Infrastructure."
    },
    {
      q:"Natgrid (National Intelligence Grid) is best described as:",
      options:[
        "An integrated intelligence grid connecting databases of core security agencies",
        "A cyber awareness course for school students",
        "A state-wise scholarship scheme",
        "A VPN service for government staff"
      ],
      correctText:"An integrated intelligence grid connecting databases of core security agencies",
      hint:"Integrated grid + databases.",
      fb:"Natgrid enables secure access to multiple databases for intelligence/investigation."
    },
    {
      q:"CCTNS aims mainly to:",
      options:[
        "Network police stations and enable crime/criminal tracking across locations",
        "Replace CERT-In operations",
        "Publish ISO standards for networks",
        "Provide only cyber posters"
      ],
      correctText:"Network police stations and enable crime/criminal tracking across locations",
      hint:"Police network + tracking.",
      fb:"CCTNS links police stations and supports nationwide crime and criminal tracking."
    },
    {
      q:"NCCC is intended primarily for:",
      options:[
        "Cyber coordination and monitoring with intelligence support",
        "Only academic curriculum approval",
        "Only software licensing management",
        "Only online exam scheduling"
      ],
      correctText:"Cyber coordination and monitoring with intelligence support",
      hint:"Coordination + monitoring.",
      fb:"NCCC is described as a cyber coordination/monitoring center supporting national security."
    },
    {
      q:"A Botnet Cleaning Center is meant to:",
      options:[
        "Detect botnets/malware and help users remove them from infected devices",
        "Provide email accounts to all citizens",
        "Replace police investigation systems",
        "Issue ISO certificates"
      ],
      correctText:"Detect botnets/malware and help users remove them from infected devices",
      hint:"Cleaning infected devices.",
      fb:"Botnet cleaning initiatives help detect and remove infections from user devices."
    },
    {
      q:"NISAP focuses mainly on:",
      options:[
        "Information security awareness and implementation support aligned to ISMS practices",
        "Border management and disaster response",
        "Tax intelligence database integration",
        "Replacing security tools with only open-source tools"
      ],
      correctText:"Information security awareness and implementation support aligned to ISMS practices",
      hint:"ISMS-like awareness.",
      fb:"NISAP supports strengthening information security practices and awareness."
    },
    {
      q:"NCTC (proposed) was mainly to:",
      options:[
        "Coordinate counter-terrorism measures among state and central agencies",
        "Certify mobile phones for secure use",
        "Run cyber forensics labs in every district",
        "Issue email rules for universities"
      ],
      correctText:"Coordinate counter-terrorism measures among state and central agencies",
      hint:"Counter-terror coordination.",
      fb:"NCTC was proposed as a centralized mechanism for counter-terror coordination."
    },
    {
      q:"Government e-mail policy is mainly about:",
      options:[
        "Guidelines and safe practices for official e-mail usage",
        "Replacing internet with intranet",
        "Banning passwords in government",
        "Forcing only one email provider for private sector"
      ],
      correctText:"Guidelines and safe practices for official e-mail usage",
      hint:"Usage guidelines.",
      fb:"Email policy focuses on secure, appropriate use of official email systems."
    },
    {
      q:"Indo–US Cyber Security Forum (IUSCSF) supports:",
      options:[
        "Bilateral cooperation and dialogue on cyber security issues",
        "Maintaining India’s national crime records",
        "Operating CCTNS networks",
        "Issuing ISO certificates"
      ],
      correctText:"Bilateral cooperation and dialogue on cyber security issues",
      hint:"Bilateral forum.",
      fb:"IUSCSF strengthens cooperation and dialogue between India and the US on cyber security."
    },
    {
      q:"DSCI (Data Security Council of India) is best described as:",
      options:[
        "An industry-led body promoting data security and privacy culture in India",
        "A police station networking project",
        "A counter-terror intelligence grid",
        "A malware cleaning tool"
      ],
      correctText:"An industry-led body promoting data security and privacy culture in India",
      hint:"Industry body + data security.",
      fb:"DSCI works with industry and stakeholders to strengthen data protection practices."
    },
    {
      q:"Which is a typical NCIIPC-related activity?",
      options:[
        "Malware analysis and alerts/advisories for critical sectors",
        "Issuing driving licenses for cyber vehicles",
        "Only publishing cyber news articles",
        "Only doing annual university rankings"
      ],
      correctText:"Malware analysis and alerts/advisories for critical sectors",
      hint:"Think: technical operations.",
      fb:"NCIIPC supports monitoring, analysis, and advisories for critical infrastructure security."
    }
  ];

  // 12 lap themes (visual variety)
  const THEMES = [
    { name:"Neon Blue",   lane:"rgba(90,228,255,0.10)",  kerbA:"rgba(255,77,109,0.90)", kerbB:"rgba(255,255,255,0.80)", halo:"rgba(90,228,255,0.22)" },
    { name:"Cyber Green", lane:"rgba(53,242,140,0.10)",  kerbA:"rgba(53,242,140,0.88)", kerbB:"rgba(255,255,255,0.78)", halo:"rgba(53,242,140,0.18)" },
    { name:"Hot Pink",    lane:"rgba(255,77,109,0.09)",  kerbA:"rgba(255,209,102,0.88)", kerbB:"rgba(255,255,255,0.78)", halo:"rgba(255,77,109,0.18)" },
    { name:"Amber",       lane:"rgba(255,209,102,0.08)", kerbA:"rgba(255,77,109,0.88)", kerbB:"rgba(255,255,255,0.78)", halo:"rgba(255,209,102,0.18)" },
    { name:"Violet",      lane:"rgba(167,139,250,0.10)", kerbA:"rgba(167,139,250,0.90)", kerbB:"rgba(255,255,255,0.78)", halo:"rgba(167,139,250,0.18)" },
    { name:"Aqua",        lane:"rgba(90,228,255,0.08)",  kerbA:"rgba(53,242,140,0.88)", kerbB:"rgba(255,255,255,0.78)", halo:"rgba(90,228,255,0.16)" },
    { name:"Lime",        lane:"rgba(53,242,140,0.08)",  kerbA:"rgba(255,209,102,0.88)", kerbB:"rgba(255,255,255,0.78)", halo:"rgba(53,242,140,0.16)" },
    { name:"Rose",        lane:"rgba(255,77,109,0.08)",  kerbA:"rgba(90,228,255,0.88)", kerbB:"rgba(255,255,255,0.78)", halo:"rgba(255,77,109,0.16)" },
    { name:"Ice",         lane:"rgba(234,240,255,0.07)", kerbA:"rgba(90,228,255,0.86)", kerbB:"rgba(255,255,255,0.80)", halo:"rgba(234,240,255,0.14)" },
    { name:"Gold",        lane:"rgba(255,209,102,0.07)", kerbA:"rgba(255,209,102,0.90)", kerbB:"rgba(255,255,255,0.78)", halo:"rgba(255,209,102,0.16)" },
    { name:"Spectrum",    lane:"rgba(255,255,255,0.06)", kerbA:"rgba(255,77,109,0.88)", kerbB:"rgba(53,242,140,0.86)",  halo:"rgba(90,228,255,0.16)" },
    { name:"Finale",      lane:"rgba(90,228,255,0.08)",  kerbA:"rgba(255,209,102,0.90)", kerbB:"rgba(255,255,255,0.80)", halo:"rgba(255,77,109,0.16)" }
  ];

  // ============================================================
  // DOM
  // ============================================================
  const stage = document.getElementById('stage');
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const overlay = document.getElementById('overlay');
  const lapText = document.getElementById('lapText');
  const themeText = document.getElementById('themeText');
  const stateText = document.getElementById('stateText');

  const qLap  = document.getElementById('qLap');
  const qText = document.getElementById('qText');
  const optsDiv = document.getElementById('opts');
  const hintText = document.getElementById('hintText');
  const fbText = document.getElementById('fbText');

  document.getElementById('startBtn').addEventListener('click', startGame);
  document.getElementById('resetBtn').addEventListener('click', resetGame);

  // ============================================================
  // Sound (optional)
  // ============================================================
  let soundOn = false;
  let audioCtx = null;
  const soundBtn = document.getElementById('soundBtn');
  soundBtn.addEventListener('click', async () => {
    soundOn = !soundOn;
    soundBtn.textContent = `Sound: ${soundOn ? "On" : "Off"}`;
    soundBtn.setAttribute('aria-pressed', soundOn ? "true" : "false");
    if(soundOn){
      try{
        if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if(audioCtx.state === "suspended") await audioCtx.resume();
        beep(620, 0.05, 'triangle', 0.02);
      }catch(_){}
    }
  });
  function beep(freq=440, dur=0.08, type='sine', gain=0.03){
    if(!soundOn) return;
    if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const t0 = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type; o.frequency.value = freq;
    g.gain.setValueAtTime(gain, t0);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
    o.connect(g).connect(audioCtx.destination);
    o.start(t0);
    o.stop(t0 + dur);
  }

  // ============================================================
  // Helpers
  // ============================================================
  function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
  function lerp(a,b,t){ return a + (b-a)*t; }
  function shuffleInPlace(a){
    for(let i=a.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  // ============================================================
  // Canvas sizing
  // ============================================================
  const DPR_CAP = 1.5;
  let dpr = 1;
  function resize(){
    const r = stage.getBoundingClientRect();
    dpr = Math.min(DPR_CAP, window.devicePixelRatio || 1);
    canvas.width = Math.floor(r.width * dpr);
    canvas.height = Math.floor(r.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    buildTrackGeometry();
    renderTrackToMap(); // uses current theme
  }
  window.addEventListener('resize', resize);

  // ============================================================
  // GAME STATE
  // ============================================================
  const TOTAL_LAPS = 12;
  const STATE = { READY:"READY", RUN:"RUN", MCQ:"MCQ", FEED:"FEED", DONE:"DONE" };

  const game = {
    state: STATE.READY,
    lap: 0,
    s: 0,
    prevS: 0,
    speed: 0,
    targetSpeed: 0,
    cruise: 0.14,
    boost: 0.20,
    glow: 0,
    shake: 0,
    wrongBlink: 0,

    // questions
    qOrder: [],
    currentQ: null,
    canAnswer: true,
    feedbackNext: null,
    tState: 0,
    _boostT: null
  };

  function setState(s){
    game.state = s;
    game.tState = 0;
    stateText.textContent =
      s===STATE.READY ? "Ready" :
      s===STATE.RUN ? "Racing" :
      s===STATE.MCQ ? "Question" :
      s===STATE.FEED ? "Feedback" :
      s===STATE.DONE ? "Finished" : s;
  }

  function updateTopPills(){
    lapText.textContent = `Lap ${Math.min(game.lap, TOTAL_LAPS)}/${TOTAL_LAPS}`;
    const t = THEMES[Math.min(game.lap, TOTAL_LAPS-1)];
    themeText.textContent = `Theme ${Math.min(game.lap+1, TOTAL_LAPS)}/${TOTAL_LAPS}`;
    themeText.title = t ? t.name : "";
  }

  // ============================================================
  // Track geometry + themed rendering
  // ============================================================
  let W=0,H=0;
  const track = {
    pts: [],
    tang: [],
    nrm: [],
    width: 0,
    startIdx: 0,
    mapCanvas: null,
    mapCtx: null
  };

  function unit(x,y){
    const m = Math.hypot(x,y) || 1;
    return {x:x/m,y:y/m};
  }

  function buildTrackGeometry(){
    const r = stage.getBoundingClientRect();
    W = r.width; H = r.height;

    const cx = W*0.52;
    const cy = H*0.54;

    const base = Math.min(W,H);
    const a = base * 0.46;
    const b = base * 0.34;

    const wobA = 0.06;
    const wobB = 0.05;

    const N = 980;
    const pts = [];
    for(let i=0;i<N;i++){
      const t = (i/N) * Math.PI*2;

      let x = cx + a * Math.cos(t);
      let y = cy + b * Math.sin(t);

      x += Math.sin(2*t + 0.6) * a * wobA * 0.18;
      y += Math.sin(3*t + 1.1) * b * wobB * 0.18;

      const bump = Math.exp(-Math.pow((t - 1.35),2)/(2*0.16*0.16));
      x += bump * 16;
      y -= bump * 10;

      pts.push({x,y});
    }

    const tang = new Array(N);
    const nrm  = new Array(N);
    for(let i=0;i<N;i++){
      const p0 = pts[(i-1+N)%N];
      const p1 = pts[(i+1)%N];
      const u = unit(p1.x - p0.x, p1.y - p0.y);
      tang[i] = u;
      nrm[i] = {x: -u.y, y: u.x};
    }

    track.pts = pts;
    track.tang = tang;
    track.nrm = nrm;

    track.width = base * 0.16;
    track.startIdx = Math.floor(N * 0.02);

    if(!track.mapCanvas){
      track.mapCanvas = document.createElement('canvas');
      track.mapCtx = track.mapCanvas.getContext('2d');
    }
    track.mapCanvas.width = Math.floor(W * dpr);
    track.mapCanvas.height = Math.floor(H * dpr);
    track.mapCtx.setTransform(dpr,0,0,dpr,0,0);
  }

  function renderTrackToMap(){
    const mctx = track.mapCtx;
    if(!mctx) return;

    const theme = THEMES[Math.min(game.lap, TOTAL_LAPS-1)];
    const laneTint = theme?.lane || "rgba(90,228,255,0.08)";
    const haloCol  = theme?.halo || "rgba(90,228,255,0.18)";
    const kerbA    = theme?.kerbA || "rgba(255,77,109,0.88)";
    const kerbB    = theme?.kerbB || "rgba(255,255,255,0.78)";

    mctx.clearRect(0,0,W,H);

    // background
    const g = mctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, "rgba(10,16,30,0.70)");
    g.addColorStop(1, "rgba(8,10,18,0.86)");
    mctx.fillStyle = g;
    mctx.fillRect(0,0,W,H);

    // grass speckles (slight theme influence)
    mctx.save();
    mctx.globalAlpha = 0.14;
    for(let i=0;i<820;i++){
      const x = Math.random()*W;
      const y = Math.random()*H;
      const r = 1 + Math.random()*2.8;
      mctx.fillStyle = (Math.random()<0.5) ? "rgba(53,242,140,0.23)" : haloCol;
      mctx.beginPath(); mctx.arc(x,y,r,0,Math.PI*2); mctx.fill();
    }
    mctx.restore();

    // outer halo
    mctx.save();
    mctx.globalAlpha = 0.28;
    mctx.strokeStyle = haloCol;
    mctx.lineWidth = track.width + 54;
    mctx.lineCap = "round";
    mctx.beginPath();
    const p0 = track.pts[0];
    mctx.moveTo(p0.x,p0.y);
    for(const p of track.pts) mctx.lineTo(p.x,p.y);
    mctx.closePath();
    mctx.stroke();
    mctx.restore();

    // asphalt
    mctx.save();
    mctx.lineCap = "round";
    mctx.lineJoin = "round";
    mctx.strokeStyle = "rgba(10,14,26,0.96)";
    mctx.lineWidth = track.width;
    mctx.beginPath();
    mctx.moveTo(track.pts[0].x, track.pts[0].y);
    for(const p of track.pts) mctx.lineTo(p.x,p.y);
    mctx.closePath();
    mctx.stroke();
    mctx.restore();

    // lane tint (theme)
    mctx.save();
    mctx.globalAlpha = 1;
    mctx.strokeStyle = laneTint;
    mctx.lineWidth = track.width * 0.86;
    mctx.lineCap = "round";
    mctx.beginPath();
    mctx.moveTo(track.pts[0].x, track.pts[0].y);
    for(const p of track.pts) mctx.lineTo(p.x,p.y);
    mctx.closePath();
    mctx.stroke();
    mctx.restore();

    // asphalt texture
    mctx.save();
    mctx.globalAlpha = 0.14;
    for(let i=0;i<1400;i++){
      const idx = Math.floor(Math.random()*track.pts.length);
      const p = track.pts[idx];
      const nx = track.nrm[idx].x, ny = track.nrm[idx].y;
      const off = (Math.random()-0.5) * (track.width*0.88);
      const x = p.x + nx*off + (Math.random()-0.5)*2;
      const y = p.y + ny*off + (Math.random()-0.5)*2;
      mctx.fillStyle = (Math.random()<0.5) ? "rgba(255,255,255,0.18)" : "rgba(0,0,0,0.35)";
      mctx.fillRect(x,y,1,1);
    }
    mctx.restore();

    // kerbs
    function drawKerb(sideSign, alpha){
      mctx.save();
      mctx.globalAlpha = alpha;
      mctx.lineCap = "butt";
      mctx.lineWidth = 9;
      for(let i=0;i<track.pts.length;i+=10){
        const p = track.pts[i];
        const nx = track.nrm[i].x, ny = track.nrm[i].y;
        const x = p.x + nx * sideSign * (track.width*0.52);
        const y = p.y + ny * sideSign * (track.width*0.52);
        const on = (Math.floor(i/10) % 2) === 0;
        mctx.strokeStyle = on ? kerbA : kerbB;
        mctx.beginPath();
        mctx.moveTo(x, y);
        const p2 = track.pts[(i+8)%track.pts.length];
        const x2 = p2.x + track.nrm[(i+8)%track.pts.length].x * sideSign * (track.width*0.52);
        const y2 = p2.y + track.nrm[(i+8)%track.pts.length].y * sideSign * (track.width*0.52);
        mctx.lineTo(x2,y2);
        mctx.stroke();
      }
      mctx.restore();
    }
    drawKerb(+1, 0.90);
    drawKerb(-1, 0.90);

    // center dashed
    mctx.save();
    mctx.globalAlpha = 0.55;
    mctx.lineWidth = 2;
    mctx.strokeStyle = "rgba(255,255,255,0.22)";
    for(let i=0;i<track.pts.length;i+=16){
      const p = track.pts[i];
      const p2 = track.pts[(i+8)%track.pts.length];
      mctx.beginPath();
      mctx.moveTo(p.x,p.y);
      mctx.lineTo(p2.x,p2.y);
      mctx.stroke();
    }
    mctx.restore();

    drawFinishLine(mctx);
  }

  function drawFinishLine(mctx){
    const i = track.startIdx;
    const p = track.pts[i];
    const t = track.tang[i];

    const w = track.width*0.92;
    const h = 18;

    mctx.save();
    mctx.translate(p.x, p.y);
    mctx.rotate(Math.atan2(t.y, t.x));
    mctx.globalAlpha = 0.95;

    const cols = 12;
    for(let c=0;c<cols;c++){
      mctx.fillStyle = (c%2===0) ? "rgba(255,255,255,0.85)" : "rgba(0,0,0,0.85)";
      mctx.fillRect(-w/2 + (c/cols)*w, -h/2, w/cols, h);
    }
    mctx.strokeStyle = "rgba(90,228,255,0.25)";
    mctx.lineWidth = 2;
    mctx.strokeRect(-w/2, -h/2, w, h);
    mctx.restore();
  }

  // ============================================================
  // MCQ preparation (shuffles options; correct index recalculated)
  // ============================================================
  function prepareQuestion(base){
    const opts = base.options.slice();
    shuffleInPlace(opts);
    const answerIdx = opts.indexOf(base.correctText);
    // Safety: if text mismatch happens, fall back to original index
    const safeAnswer = (answerIdx >= 0) ? answerIdx : base.options.indexOf(base.correctText);
    return {
      q: base.q,
      options: opts,
      answer: safeAnswer >= 0 ? safeAnswer : 0,
      hint: base.hint || "Choose the best answer.",
      fb: base.fb || ""
    };
  }

  function buildQuestionOrder(){
    // Use all 12, but shuffle order
    const copy = QUESTIONS_BASE.slice();
    shuffleInPlace(copy);
    game.qOrder = copy.map(q => prepareQuestion(q));
  }

  // ============================================================
  // Overlay
  // ============================================================
  function showMCQ(){ overlay.classList.add("show"); }
  function hideOverlay(){ overlay.classList.remove("show"); }

  function lockOptions(lock){
    [...optsDiv.querySelectorAll(".opt")].forEach(el => {
      el.style.pointerEvents = lock ? "none" : "auto";
      el.style.opacity = lock ? "0.92" : "1";
    });
  }
  function mark(i, cls){
    const el = optsDiv.querySelector(`.opt[data-idx="${i}"]`);
    if(el) el.classList.add(cls);
  }

  function openMCQ(){
    game.currentQ = game.qOrder[game.lap];
    game.canAnswer = true;

    qLap.textContent = `Lap ${game.lap+1}/${TOTAL_LAPS}`;
    qText.textContent = game.currentQ.q;

    hintText.textContent = `Tip: ${game.currentQ.hint || "Choose the best answer."}`;
    fbText.textContent = "";
    optsDiv.innerHTML = "";

    const letters = ["A","B","C","D"];
    game.currentQ.options.forEach((t,i) => {
      const el = document.createElement("div");
      el.className = "opt";
      el.dataset.idx = String(i);
      el.innerHTML = `<div class="badge">${letters[i]}</div>
                      <div style="min-width:0"><div style="font-weight:760; font-size:13px; line-height:1.25">${t}</div></div>`;
      el.addEventListener("click", () => choose(i));
      optsDiv.appendChild(el);
    });

    showMCQ();
    setState(STATE.MCQ);
    beep(520, 0.06, 'triangle', 0.02);
  }

  function choose(i){
    if(game.state !== STATE.MCQ || !game.canAnswer) return;
    game.canAnswer = false;
    lockOptions(true);

    const correct = game.currentQ.answer;
    const ok = (i === correct);

    if(ok){
      mark(i,"good");
      fbText.textContent = "Correct. Starting next lap…";
      game.feedbackNext = "advance";
      game.glow = 1.0;
      beep(760, 0.08, 'sine', 0.03);
      setState(STATE.FEED);
    } else {
      mark(i,"bad");
      mark(correct,"good");
      fbText.textContent = game.currentQ.fb || "Incorrect. Try again.";
      game.feedbackNext = "retry";
      game.shake = 0.35;
      game.wrongBlink = 0.8;
      beep(220, 0.10, 'sawtooth', 0.015);
      setState(STATE.FEED);
    }
  }

  window.addEventListener("keydown", (e) => {
    if(game.state !== STATE.MCQ) return;
    const map = {a:0,b:1,c:2,d:3};
    const k = e.key.toLowerCase();
    if(map[k] !== undefined){
      e.preventDefault();
      choose(map[k]);
    }
  });

  // ============================================================
  // Particles (light)
  // ============================================================
  const particles = [];
  const MAX_PARTICLES = 90;

  function spawnParticles(x,y,n,kind){
    for(let i=0;i<n;i++){
      if(particles.length>=MAX_PARTICLES) break;
      const a = Math.random()*Math.PI*2;
      const sp = (kind==='confetti'?60:120) + Math.random()*140;
      particles.push({
        x,y,
        vx: Math.cos(a)*sp,
        vy: Math.sin(a)*sp,
        t:0,
        life: (kind==='confetti'?1.4:0.7)+Math.random()*0.35,
        kind,
        rot: Math.random()*6.28,
        vr: (Math.random()-0.5)*9,
        s: (kind==='confetti'?6:3)+Math.random()*5
      });
    }
  }
  function updateParticles(dt){
    for(let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      p.t += dt;
      const k = 1 - p.t/p.life;
      p.vy += (p.kind==='confetti'?110:200)*dt;
      p.x += p.vx*dt;
      p.y += p.vy*dt;
      p.vx *= 0.985;
      p.rot += p.vr*dt;
      if(k<=0) particles.splice(i,1);
    }
  }
  function drawParticles(){
    for(const p of particles){
      const k = Math.max(0, 1 - p.t/p.life);
      ctx.save();
      ctx.globalAlpha = 0.9*k;
      if(p.kind==='confetti'){
        ctx.translate(p.x,p.y);
        ctx.rotate(p.rot);
        ctx.fillStyle = "rgba(255,255,255,0.78)";
        ctx.fillRect(-p.s/2,-p.s/2,p.s,p.s*0.65);
      } else {
        const r = 18*p.s/8;
        const g = ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,r);
        g.addColorStop(0,"rgba(255,209,102,0.22)");
        g.addColorStop(1,"rgba(0,0,0,0)");
        ctx.fillStyle = g;
        ctx.beginPath(); ctx.arc(p.x,p.y,r,0,Math.PI*2); ctx.fill();
      }
      ctx.restore();
    }
  }

  // ============================================================
  // Car drawing
  // ============================================================
  function roundRectPath(x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
  }

  function drawCar(x,y,angle){
    ctx.save();
    ctx.translate(x,y);
    ctx.rotate(angle);

    // shadow
    ctx.globalAlpha = 0.28;
    ctx.fillStyle = "rgba(0,0,0,0.85)";
    ctx.beginPath();
    ctx.ellipse(0, 18, 20, 10, 0, 0, Math.PI*2);
    ctx.fill();

    // glow on correct
    if(game.glow>0.02){
      ctx.globalAlpha = 0.55*game.glow;
      let g = ctx.createRadialGradient(0,12,0,0,12,72);
      g.addColorStop(0,"rgba(53,242,140,0.20)");
      g.addColorStop(1,"rgba(0,0,0,0)");
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(0,12,72,0,Math.PI*2); ctx.fill();
    }

    ctx.globalAlpha = 1;
    const shell = ctx.createLinearGradient(-24,-46,24,46);
    shell.addColorStop(0, "rgba(255,77,109,0.34)");
    shell.addColorStop(0.45, "rgba(90,228,255,0.42)");
    shell.addColorStop(1, "rgba(53,242,140,0.28)");

    ctx.fillStyle = "rgba(255,255,255,0.10)";
    roundRectPath(-20,-40,40,80,16);
    ctx.fill();

    ctx.fillStyle = shell;
    roundRectPath(-17,-37,34,74,14);
    ctx.fill();

    ctx.fillStyle = "rgba(255,255,255,0.14)";
    roundRectPath(-4,-37,8,74,6);
    ctx.fill();

    ctx.fillStyle = "rgba(10,14,26,0.65)";
    roundRectPath(-12,-20,24,26,10);
    ctx.fill();

    ctx.fillStyle = "rgba(0,0,0,0.70)";
    roundRectPath(-21,-28,7,16,4); ctx.fill();
    roundRectPath(14,-28,7,16,4); ctx.fill();
    roundRectPath(-21,12,7,16,4); ctx.fill();
    roundRectPath(14,12,7,16,4); ctx.fill();

    ctx.fillStyle = "rgba(255,209,102,0.68)";
    roundRectPath(-13,-40,9,11,5); ctx.fill();
    roundRectPath(4,-40,9,11,5); ctx.fill();

    ctx.fillStyle = (game.wrongBlink>0) ? "rgba(255,77,109,0.88)" : "rgba(255,77,109,0.32)";
    roundRectPath(-13,29,9,11,5); ctx.fill();
    roundRectPath(4,29,9,11,5); ctx.fill();

    ctx.globalAlpha = 0.9;
    ctx.fillStyle = "rgba(255,255,255,0.10)";
    roundRectPath(-13,38,26,6,4);
    ctx.fill();

    ctx.restore();
  }

  // ============================================================
  // Update + render
  // ============================================================
  let last=0;
  function tick(ts){
    if(!last) last = ts;
    const dt = Math.min(0.033, (ts-last)/1000);
    last = ts;

    game.tState += dt;
    game.shake = Math.max(0, game.shake - dt*0.95);
    game.glow = Math.max(0, game.glow - dt*0.85);
    game.wrongBlink = Math.max(0, game.wrongBlink - dt);

    game.speed = lerp(game.speed, game.targetSpeed, 0.07);

    if(game.state === STATE.RUN){
      game.prevS = game.s;
      game.s = (game.s + game.speed*dt) % 1;

      // lap complete = wrap
      if(game.prevS > 0.92 && game.s < 0.08){
        // checkpoint MCQ at end of lap
        game.targetSpeed = 0;
        openMCQ();
      }
    }

    if(game.state === STATE.FEED){
      const hold = 0.95;
      if(game.tState >= hold){
        if(game.feedbackNext === "advance"){
          hideOverlay();
          game.lap += 1;
          updateTopPills();

          if(game.lap >= TOTAL_LAPS){
            setState(STATE.DONE);
            game.targetSpeed = 0;
            const fp = track.pts[track.startIdx];
            spawnParticles(fp.x, fp.y, 36, "confetti");
            spawnParticles(fp.x+22, fp.y-10, 36, "confetti");
            beep(660, 0.10, "sine", 0.03);
          } else {
            // NEW: change track look each lap
            renderTrackToMap();

            game.s = 0.08;
            game.prevS = game.s;
            setState(STATE.RUN);
            game.targetSpeed = game.boost;
            game.glow = 1.0;
            const car = sampleTrack(game.s);
            spawnParticles(car.x, car.y, 14, "dust");
            beep(740, 0.06, "triangle", 0.02);
            game._boostT = 0.7;
          }
        } else {
          // wrong: retry same lap (same theme)
          hideOverlay();
          setState(STATE.RUN);
          game.targetSpeed = game.cruise;
        }
      }
    }

    if(game._boostT){
      game._boostT -= dt;
      if(game._boostT <= 0){
        game._boostT = null;
        if(game.state === STATE.RUN) game.targetSpeed = game.cruise;
      }
    }

    updateParticles(dt);
    render();
    requestAnimationFrame(tick);
  }

  function render(){
    ctx.clearRect(0,0,W,H);

    const sx = (Math.random()-0.5) * 8 * game.shake;
    const sy = (Math.random()-0.5) * 8 * game.shake;
    ctx.save();
    ctx.translate(sx,sy);

    if(track.mapCanvas) ctx.drawImage(track.mapCanvas, 0, 0, W, H);

    drawHUD();

    const car = sampleTrack(game.s);
    const ang = Math.atan2(car.ty, car.tx) + Math.PI/2;
    drawCar(car.x, car.y, ang);

    drawParticles();
    ctx.restore();
  }

  function drawHUD(){
    const pad = 14;
    const r = 16;
    const x = pad + 20;
    const y = H - pad - 30;

    ctx.save();
    ctx.globalAlpha = 0.95;
    ctx.lineWidth = 3;
    ctx.strokeStyle = "rgba(255,255,255,0.16)";
    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.stroke();

    const frac = game.s;
    ctx.strokeStyle = "rgba(90,228,255,0.55)";
    ctx.beginPath();
    ctx.arc(x,y,r, -Math.PI/2, -Math.PI/2 + Math.PI*2*frac);
    ctx.stroke();

    ctx.fillStyle = "rgba(234,240,255,0.84)";
    ctx.font = "700 12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    const lapShown = Math.min(game.lap, TOTAL_LAPS);
    ctx.fillText(`Lap ${lapShown}/${TOTAL_LAPS}`, x+28, y);

    ctx.restore();
  }

  function sampleTrack(s){
    const N = track.pts.length;
    const idx = Math.floor(s * N) % N;
    const p = track.pts[idx];
    const t = track.tang[idx];
    return {x:p.x, y:p.y, tx:t.x, ty:t.y, idx};
  }

  // ============================================================
  // Start / Reset
  // ============================================================
  function resetGame(){
    overlay.classList.remove("show");
    particles.length = 0;

    game.lap = 0;
    game.s = 0.10;
    game.prevS = game.s;

    game.speed = 0;
    game.targetSpeed = 0;

    game.glow = 0;
    game.shake = 0;
    game.wrongBlink = 0;

    buildQuestionOrder();
    updateTopPills();
    renderTrackToMap();

    setState(STATE.READY);
  }

  function startGame(){
    if(game.state === STATE.DONE) resetGame();
    if(game.state === STATE.RUN) return;
    setState(STATE.RUN);
    game.targetSpeed = game.cruise;
    const car = sampleTrack(game.s);
    spawnParticles(car.x, car.y, 10, "dust");
  }

  // ============================================================
  // Init
  // ============================================================
  function init(){
    resize();
    resetGame();
    requestAnimationFrame(tick);
  }
  init();

})();
</script>
</body>
</html>

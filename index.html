<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Cyber Lap Race — 12 Different Laps</title>
  <style>
    :root{
      --bg:#070A12;
      --ink:#EAF0FF;
      --muted: rgba(234,240,255,0.72);
      --stroke: rgba(255,255,255,0.14);
      --shadow: rgba(0,0,0,0.40);

      --cyan:#5AE4FF;
      --green:#35F28C;
      --pink:#FF4D6D;
      --amber:#FFD166;
      --violet:#A78BFA;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:var(--ink);
      background:
        radial-gradient(1200px 780px at 18% 8%, rgba(90,228,255,0.18), transparent 55%),
        radial-gradient(1100px 760px at 78% 22%, rgba(53,242,140,0.12), transparent 58%),
        radial-gradient(1100px 760px at 50% 110%, rgba(255,77,109,0.10), transparent 58%),
        var(--bg);
      overflow:hidden;
    }
    .wrap{max-width:1200px;margin:0 auto;padding:12px}
    .card{
      border:1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.04));
      border-radius:18px;
      box-shadow: 0 18px 44px var(--shadow);
      overflow:hidden;
    }
    .topbar{
      display:flex; align-items:center; justify-content:space-between;
      padding: 12px 14px;
      border-bottom: 1px solid rgba(255,255,255,0.10);
      background: rgba(10,14,26,0.52);
      backdrop-filter: blur(6px);
      gap: 12px; flex-wrap:wrap;
    }
    .brand{ display:flex; align-items:center; gap:10px; min-width: 260px; }
    .logo{
      width:14px; height:14px; border-radius:50%;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.9), rgba(90,228,255,0.95) 55%, rgba(90,228,255,0.15));
      box-shadow: 0 0 18px rgba(90,228,255,0.60);
      flex:0 0 auto;
    }
    .title{ font-weight: 820; letter-spacing:0.2px; line-height:1.1; }
    .subtitle{ font-size: 12px; color: var(--muted); margin-top: 2px; }

    .pills{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; justify-content:flex-end; }
    .pill{
      display:flex; gap:8px; align-items:center;
      padding: 7px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      font-size: 12px;
      color: rgba(234,240,255,0.90);
      white-space:nowrap;
    }
    .pill b{ color: var(--ink); }
    .dot{
      width: 7px; height: 7px; border-radius: 50%;
      background: var(--cyan);
      box-shadow: 0 0 12px rgba(90,228,255,0.65);
    }
    .btnrow{ display:flex; gap:10px; flex-wrap:wrap; }
    button{
      appearance:none;
      border: 1px solid rgba(255,255,255,0.16);
      background: linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.05));
      color: var(--ink);
      border-radius: 12px;
      padding: 9px 12px;
      font-weight: 740;
      cursor:pointer;
      box-shadow: 0 10px 24px rgba(0,0,0,0.28);
      transition: transform .12s ease, border-color .12s ease;
      font-size: 12px;
    }
    button:hover{ transform: translateY(-1px); border-color: rgba(90,228,255,0.35); }
    button:active{ transform: translateY(0px) scale(0.99); }
    button.primary{
      border-color: rgba(90,228,255,0.50);
      background: linear-gradient(180deg, rgba(90,228,255,0.22), rgba(90,228,255,0.10));
    }

    .stage{
      position: relative;
      height: min(78vh, 720px);
      min-height: 420px;
      background:
        radial-gradient(1100px 760px at 50% 50%, rgba(255,255,255,0.06), transparent 60%),
        linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.06));
    }
    @media (max-width: 560px){
      .stage{ height: 74vh; min-height: 520px; }
      .subtitle{ display:none; }
    }
    canvas{ width:100%; height:100%; display:block; }

    /* MCQ overlay */
    .overlay{
      position:absolute; inset:0;
      display:none;
      align-items:center; justify-content:center;
      padding: 16px;
      background: rgba(0,0,0,0.55);
      backdrop-filter: blur(8px);
    }
    .overlay.show{ display:flex; }

    .panel{
      width: min(920px, 100%);
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.16);
      background: linear-gradient(180deg, rgba(10,14,26,0.92), rgba(10,14,26,0.78));
      box-shadow: 0 26px 60px rgba(0,0,0,0.55);
      overflow:hidden;
    }
    .phead{
      padding: 14px;
      border-bottom: 1px solid rgba(255,255,255,0.10);
      display:flex; align-items:flex-start; justify-content:space-between; gap:10px;
      background:
        radial-gradient(520px 240px at 20% 0%, rgba(90,228,255,0.14), transparent 60%),
        radial-gradient(520px 240px at 80% 0%, rgba(255,77,109,0.10), transparent 60%);
    }
    .phead .t{ font-weight: 860; letter-spacing:0.2px; }
    .phead .m{ font-size: 12px; color: var(--muted); margin-top: 3px; }
    .badgeP{
      padding: 7px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      font-size: 12px;
      white-space:nowrap;
    }
    .pbody{ padding: 14px; }

    .qtext{ font-size: 16px; line-height: 1.35; margin: 0 0 12px; color: rgba(234,240,255,0.95); }
    .opts{ display:grid; gap:10px; grid-template-columns: 1fr 1fr; }
    @media (max-width: 640px){ .opts{ grid-template-columns: 1fr; } }
    .opt{
      text-align:left;
      padding: 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.05);
      cursor:pointer;
      transition: transform .12s ease, border-color .12s ease, background .12s ease;
      min-height: 54px;
      display:flex; gap:10px; align-items:flex-start;
      user-select:none;
    }
    .opt:hover{ transform: translateY(-1px); border-color: rgba(90,228,255,0.35); }
    .badge{
      width: 26px; height: 26px; border-radius: 10px;
      display:grid; place-items:center;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.06);
      font-weight: 900;
      color: rgba(234,240,255,0.92);
      flex: 0 0 auto;
    }
    .opt.good{ border-color: rgba(53,242,140,0.55); background: rgba(53,242,140,0.12); }
    .opt.bad{ border-color: rgba(255,77,109,0.60); background: rgba(255,77,109,0.10); }

    .pfoot{
      padding: 12px 14px;
      border-top: 1px solid rgba(255,255,255,0.10);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      flex-wrap:wrap;
    }
    .small{ font-size: 12px; color: var(--muted); line-height: 1.45; }
    .feedback{
      font-size: 12px; color: var(--muted);
      max-width: 72ch;
      line-height: 1.35;
    }
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.05);
      color: rgba(234,240,255,0.86);
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="card">
      <div class="topbar">
        <div class="brand">
          <span class="logo"></span>
          <div>
            <div class="title">Car Checkpoint Race</div>
            <div class="subtitle">1 full lap → 1 MCQ → unlock next lap (12 different tracks)</div>
          </div>
        </div>

        <div class="pills">
          <div class="pill"><span class="dot"></span><b id="lapText">Lap 0/12</b></div>
          <div class="pill"><span class="dot" style="background:var(--green)"></span><b id="trackText">Track 1/12</b></div>
          <div class="pill"><span class="dot" style="background:var(--amber)"></span><b id="stateText">Ready</b></div>
        </div>

        <div class="btnrow">
          <button class="primary" id="startBtn">Start</button>
          <button id="soundBtn" aria-pressed="false">Sound: Off</button>
          <button id="resetBtn">Reset</button>
        </div>
      </div>

      <div class="stage" id="stage">
        <canvas id="c"></canvas>

        <div class="overlay" id="overlay" aria-modal="true" role="dialog">
          <div class="panel">
            <div class="phead">
              <div style="min-width:0">
                <div class="t" id="qTitle">Checkpoint Question</div>
                <div class="m" id="qMeta">Correct = next lap. Wrong = retry the same lap.</div>
              </div>
              <div class="badgeP" id="qLap">Lap 1/12</div>
            </div>

            <div class="pbody">
              <p class="qtext" id="qText">Question…</p>
              <div class="opts" id="opts"></div>
            </div>

            <div class="pfoot">
              <div class="small" id="hintText">Tip…</div>
              <div class="feedback" id="fbText"></div>
              <div class="small">Keys: <span class="kbd">A</span> <span class="kbd">B</span> <span class="kbd">C</span> <span class="kbd">D</span></div>
            </div>
          </div>
        </div>
      </div><!-- stage -->
    </div>
  </div>

<script>
(() => {
  // ============================================================
  // 12 DIFFERENT TRACK STYLES (GEOMETRY + LOOK)
  // Each lap uses a different profile. Shapes stay smooth and looped.
  // ============================================================
  const CIRCUITS = [
    // a,b: radii; wob1/wob2: gentle shaping; k1/k2: harmonic shaping; chicane: localized bend
    { name:"Wide Oval",          a:0.48, b:0.33, wob1:0.00, wob2:0.00, k1:0.00, k2:0.00, chicane:0.00, tilt: 0.00 },
    { name:"Tall Oval",          a:0.42, b:0.39, wob1:0.00, wob2:0.00, k1:0.00, k2:0.00, chicane:0.00, tilt: 0.00 },
    { name:"Stadium Circuit",    a:0.46, b:0.32, wob1:0.00, wob2:0.00, k1:0.16, k2:0.06, chicane:0.00, tilt: 0.00 },
    { name:"Double Apex",        a:0.46, b:0.34, wob1:0.06, wob2:0.03, k1:0.00, k2:0.00, chicane:0.10, tilt: 0.00 },
    { name:"Offset Loop",        a:0.48, b:0.33, wob1:0.05, wob2:0.05, k1:0.06, k2:0.06, chicane:0.00, tilt: 0.00 },
    { name:"Tri-Oval",           a:0.50, b:0.30, wob1:0.00, wob2:0.00, k1:0.20, k2:0.00, chicane:0.00, tilt: 0.05 },
    { name:"Peanut (Two Bends)", a:0.44, b:0.38, wob1:0.00, wob2:0.00, k1:0.00, k2:0.22, chicane:0.00, tilt: 0.00 },
    { name:"Chicane Circuit",    a:0.46, b:0.34, wob1:0.04, wob2:0.03, k1:0.00, k2:0.00, chicane:0.18, tilt: 0.00 },
    { name:"Long Straight Bias", a:0.52, b:0.30, wob1:0.00, wob2:0.00, k1:0.12, k2:0.04, chicane:0.00, tilt: 0.00 },
    { name:"Tight Circuit",      a:0.40, b:0.32, wob1:0.06, wob2:0.05, k1:0.06, k2:0.06, chicane:0.14, tilt: 0.00 },
    { name:"Complex Oval",       a:0.48, b:0.36, wob1:0.06, wob2:0.03, k1:0.10, k2:0.08, chicane:0.16, tilt: 0.03 },
    { name:"Champion Track",     a:0.50, b:0.38, wob1:0.02, wob2:0.02, k1:0.14, k2:0.10, chicane:0.20, tilt: 0.06 }
  ];

  const THEMES = [
    { lane:"rgba(90,228,255,0.10)",  halo:"rgba(90,228,255,0.22)",  kerbA:"rgba(255,77,109,0.90)", kerbB:"rgba(255,255,255,0.80)" },
    { lane:"rgba(53,242,140,0.10)",  halo:"rgba(53,242,140,0.18)",  kerbA:"rgba(53,242,140,0.88)", kerbB:"rgba(255,255,255,0.78)" },
    { lane:"rgba(167,139,250,0.10)", halo:"rgba(167,139,250,0.18)", kerbA:"rgba(255,209,102,0.88)", kerbB:"rgba(255,255,255,0.78)" },
    { lane:"rgba(255,77,109,0.09)",  halo:"rgba(255,77,109,0.18)",  kerbA:"rgba(90,228,255,0.88)",  kerbB:"rgba(255,255,255,0.78)" },
    { lane:"rgba(255,209,102,0.08)", halo:"rgba(255,209,102,0.18)", kerbA:"rgba(255,77,109,0.88)", kerbB:"rgba(255,255,255,0.78)" },
    { lane:"rgba(90,228,255,0.08)",  halo:"rgba(90,228,255,0.16)",  kerbA:"rgba(53,242,140,0.88)", kerbB:"rgba(255,255,255,0.78)" },
    { lane:"rgba(53,242,140,0.08)",  halo:"rgba(53,242,140,0.16)",  kerbA:"rgba(167,139,250,0.90)", kerbB:"rgba(255,255,255,0.78)" },
    { lane:"rgba(255,77,109,0.08)",  halo:"rgba(255,77,109,0.16)",  kerbA:"rgba(255,209,102,0.90)", kerbB:"rgba(255,255,255,0.78)" },
    { lane:"rgba(234,240,255,0.07)", halo:"rgba(234,240,255,0.14)", kerbA:"rgba(90,228,255,0.86)",  kerbB:"rgba(255,255,255,0.80)" },
    { lane:"rgba(255,209,102,0.07)", halo:"rgba(255,209,102,0.16)", kerbA:"rgba(53,242,140,0.86)", kerbB:"rgba(255,255,255,0.78)" },
    { lane:"rgba(255,255,255,0.06)", halo:"rgba(90,228,255,0.16)",  kerbA:"rgba(255,77,109,0.88)", kerbB:"rgba(53,242,140,0.86)"  },
    { lane:"rgba(90,228,255,0.08)",  halo:"rgba(255,77,109,0.16)",  kerbA:"rgba(255,209,102,0.90)", kerbB:"rgba(255,255,255,0.80)" }
  ];

  // ============================================================
  // QUESTIONS (example 12) — Correct answer is NOT fixed at A.
  // We shuffle options per question and recompute correct index.
  // Replace these with your uploaded chapter MCQs if needed.
  // ============================================================
  const QUESTIONS_BASE = [
    { q:"CERT-In is primarily responsible for:", options:[
      "Responding to cyber incidents, vulnerability reporting, and promoting IT security practices",
      "Running state police station crime databases",
      "Issuing passports for cyber professionals",
      "Maintaining only a national email directory"
    ], correct:"Responding to cyber incidents, vulnerability reporting, and promoting IT security practices",
      hint:"National incident response team.",
      fb:"CERT-In is India’s national agency for cyber incident response and advisories." },

    { q:"NCIIPC is associated with protecting:", options:[
      "Critical Information Infrastructure (CII)",
      "Only private banking passwords",
      "Only university LMS portals",
      "Only social media accounts"
    ], correct:"Critical Information Infrastructure (CII)",
      hint:"Think: CII protection.",
      fb:"NCIIPC is the nodal body for protection of Critical Information Infrastructure." },

    { q:"Natgrid (National Intelligence Grid) is best described as:", options:[
      "An integrated intelligence grid connecting databases of core security agencies",
      "A cyber awareness course for school students",
      "A state-wise scholarship scheme",
      "A VPN service for government staff"
    ], correct:"An integrated intelligence grid connecting databases of core security agencies",
      hint:"Integrated grid + databases.",
      fb:"Natgrid enables secure access to multiple databases for intelligence/investigation." },

    { q:"CCTNS aims mainly to:", options:[
      "Network police stations and enable crime/criminal tracking across locations",
      "Replace CERT-In operations",
      "Publish ISO standards for networks",
      "Provide only cyber posters"
    ], correct:"Network police stations and enable crime/criminal tracking across locations",
      hint:"Police network + tracking.",
      fb:"CCTNS links police stations and supports nationwide crime and criminal tracking." },

    { q:"NCCC is intended primarily for:", options:[
      "Cyber coordination and monitoring with intelligence support",
      "Only academic curriculum approval",
      "Only software licensing management",
      "Only online exam scheduling"
    ], correct:"Cyber coordination and monitoring with intelligence support",
      hint:"Coordination + monitoring.",
      fb:"NCCC is described as a cyber coordination/monitoring center supporting national security." },

    { q:"A Botnet Cleaning Center is meant to:", options:[
      "Detect botnets/malware and help users remove them from infected devices",
      "Provide email accounts to all citizens",
      "Replace police investigation systems",
      "Issue ISO certificates"
    ], correct:"Detect botnets/malware and help users remove them from infected devices",
      hint:"Cleaning infected devices.",
      fb:"Botnet cleaning initiatives help detect and remove infections from user devices." },

    { q:"NISAP focuses mainly on:", options:[
      "Information security awareness and implementation support aligned to ISMS practices",
      "Border management and disaster response",
      "Tax intelligence database integration",
      "Replacing security tools with only open-source tools"
    ], correct:"Information security awareness and implementation support aligned to ISMS practices",
      hint:"ISMS-like awareness.",
      fb:"NISAP supports strengthening information security practices and awareness." },

    { q:"NCTC (proposed) was mainly to:", options:[
      "Coordinate counter-terrorism measures among state and central agencies",
      "Certify mobile phones for secure use",
      "Run cyber forensics labs in every district",
      "Issue email rules for universities"
    ], correct:"Coordinate counter-terrorism measures among state and central agencies",
      hint:"Counter-terror coordination.",
      fb:"NCTC was proposed as a centralized mechanism for counter-terror coordination." },

    { q:"Government e-mail policy is mainly about:", options:[
      "Guidelines and safe practices for official e-mail usage",
      "Replacing internet with intranet",
      "Banning passwords in government",
      "Forcing only one email provider for private sector"
    ], correct:"Guidelines and safe practices for official e-mail usage",
      hint:"Usage guidelines.",
      fb:"Email policy focuses on secure, appropriate use of official email systems." },

    { q:"Indo–US Cyber Security Forum (IUSCSF) supports:", options:[
      "Bilateral cooperation and dialogue on cyber security issues",
      "Maintaining India’s national crime records",
      "Operating CCTNS networks",
      "Issuing ISO certificates"
    ], correct:"Bilateral cooperation and dialogue on cyber security issues",
      hint:"Bilateral forum.",
      fb:"IUSCSF strengthens cooperation and dialogue between India and the US on cyber security." },

    { q:"DSCI (Data Security Council of India) is best described as:", options:[
      "An industry-led body promoting data security and privacy culture in India",
      "A police station networking project",
      "A counter-terror intelligence grid",
      "A malware cleaning tool"
    ], correct:"An industry-led body promoting data security and privacy culture in India",
      hint:"Industry body + data security.",
      fb:"DSCI works with industry and stakeholders to strengthen data protection practices." },

    { q:"Which is a typical NCIIPC-related activity?", options:[
      "Malware analysis and alerts/advisories for critical sectors",
      "Issuing driving licenses for cyber vehicles",
      "Only publishing cyber news articles",
      "Only doing annual university rankings"
    ], correct:"Malware analysis and alerts/advisories for critical sectors",
      hint:"Think: technical operations.",
      fb:"NCIIPC supports monitoring, analysis, and advisories for critical infrastructure security." },
  ];

  // ============================================================
  // DOM
  // ============================================================
  const stage = document.getElementById('stage');
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const overlay = document.getElementById('overlay');
  const lapText = document.getElementById('lapText');
  const trackText = document.getElementById('trackText');
  const stateText = document.getElementById('stateText');

  const qLap  = document.getElementById('qLap');
  const qText = document.getElementById('qText');
  const optsDiv = document.getElementById('opts');
  const hintText = document.getElementById('hintText');
  const fbText = document.getElementById('fbText');

  document.getElementById('startBtn').addEventListener('click', startGame);
  document.getElementById('resetBtn').addEventListener('click', resetGame);

  // ============================================================
  // Sound (optional)
  // ============================================================
  let soundOn = false;
  let audioCtx = null;
  const soundBtn = document.getElementById('soundBtn');
  soundBtn.addEventListener('click', async () => {
    soundOn = !soundOn;
    soundBtn.textContent = `Sound: ${soundOn ? "On" : "Off"}`;
    soundBtn.setAttribute('aria-pressed', soundOn ? "true" : "false");
    if(soundOn){
      try{
        if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if(audioCtx.state === "suspended") await audioCtx.resume();
        beep(620, 0.05, 'triangle', 0.02);
      }catch(_){}
    }
  });

  function beep(freq=440, dur=0.08, type='sine', gain=0.03){
    if(!soundOn) return;
    if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const t0 = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type; o.frequency.value = freq;
    g.gain.setValueAtTime(gain, t0);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
    o.connect(g).connect(audioCtx.destination);
    o.start(t0);
    o.stop(t0 + dur);
  }

  // ============================================================
  // Helpers
  // ============================================================
  function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
  function lerp(a,b,t){ return a + (b-a)*t; }
  function shuffle(a){
    const x = a.slice();
    for(let i=x.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [x[i], x[j]] = [x[j], x[i]];
    }
    return x;
  }

  // ============================================================
  // Canvas sizing
  // ============================================================
  const DPR_CAP = 1.5;
  let dpr = 1;
  let W=0,H=0;

  function resize(){
    const r = stage.getBoundingClientRect();
    dpr = Math.min(DPR_CAP, window.devicePixelRatio || 1);
    canvas.width = Math.floor(r.width * dpr);
    canvas.height = Math.floor(r.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    W = r.width; H = r.height;
    buildAllLapCaches(); // rebuild all tracks for new size
  }
  window.addEventListener('resize', resize);

  // ============================================================
  // GAME STATE
  // ============================================================
  const TOTAL_LAPS = 12;
  const STATE = { READY:"READY", RUN:"RUN", MCQ:"MCQ", FEED:"FEED", DONE:"DONE" };

  const game = {
    state: STATE.READY,
    lap: 0,
    s: 0.10,
    prevS: 0.10,
    speed: 0,
    targetSpeed: 0,
    cruise: 0.14,
    boost: 0.20,
    glow: 0,
    shake: 0,
    wrongBlink: 0,

    // question order (prepared with shuffling)
    qOrder: [],
    currentQ: null,
    canAnswer: true,
    feedbackNext: null,
    tState: 0,
    _boostT: null
  };

  function setState(s){
    game.state = s;
    game.tState = 0;
    stateText.textContent =
      s===STATE.READY ? "Ready" :
      s===STATE.RUN ? "Racing" :
      s===STATE.MCQ ? "Question" :
      s===STATE.FEED ? "Feedback" :
      s===STATE.DONE ? "Finished" : s;
  }

  function updateTop(){
    lapText.textContent = `Lap ${Math.min(game.lap, TOTAL_LAPS)}/${TOTAL_LAPS}`;
    trackText.textContent = `Track ${Math.min(game.lap+1, TOTAL_LAPS)}/${TOTAL_LAPS}`;
    trackText.title = CIRCUITS[Math.min(game.lap, TOTAL_LAPS-1)].name;
  }

  // ============================================================
  // TRACK BUILDING (cached per lap)
  // ============================================================
  const lapCache = new Array(TOTAL_LAPS).fill(null); // {pts,tang,nrm,width,startIdx,mapCanvas}

  function unit(x,y){
    const m = Math.hypot(x,y) || 1;
    return {x:x/m, y:y/m};
  }

  function buildTrackForLap(lapIndex){
    const profile = CIRCUITS[lapIndex];
    const theme = THEMES[lapIndex];

    const cx = W*0.52;
    const cy = H*0.54;

    const base = Math.min(W,H);
    const a = base * profile.a;
    const b = base * profile.b;

    const width = base * 0.16;
    const N = 980;

    const pts = [];
    for(let i=0;i<N;i++){
      const t = (i/N) * Math.PI*2;

      // base ellipse
      let x = cx + a * Math.cos(t);
      let y = cy + b * Math.sin(t);

      // harmonic shaping to get different circuit personalities
      // k1: 2nd harmonic, k2: 3rd harmonic
      if(profile.k1){
        x += Math.cos(2*t) * a * profile.k1 * 0.12;
        y += Math.sin(2*t) * b * profile.k1 * 0.10;
      }
      if(profile.k2){
        x += Math.cos(3*t + 0.4) * a * profile.k2 * 0.10;
        y += Math.sin(3*t + 0.8) * b * profile.k2 * 0.10;
      }

      // gentle wobble (controlled)
      if(profile.wob1){
        x += Math.sin(2*t + 0.6) * a * profile.wob1 * 0.10;
        y += Math.sin(3*t + 1.1) * b * profile.wob1 * 0.10;
      }
      if(profile.wob2){
        x += Math.sin(4*t + 0.3) * a * profile.wob2 * 0.06;
        y += Math.sin(5*t + 0.9) * b * profile.wob2 * 0.06;
      }

      // localized chicane bump (one sector)
      if(profile.chicane){
        const center = 1.28;         // fixed chicane zone
        const sigma = 0.18;
        const bump = Math.exp(-Math.pow((t-center),2)/(2*sigma*sigma));
        x += bump * profile.chicane * 120;
        y -= bump * profile.chicane * 80;
      }

      // slight tilt / banking feel (small)
      if(profile.tilt){
        x += Math.sin(t) * base * profile.tilt * 0.08;
        y += Math.cos(t) * base * profile.tilt * 0.05;
      }

      pts.push({x,y});
    }

    const tang = new Array(N);
    const nrm  = new Array(N);
    for(let i=0;i<N;i++){
      const p0 = pts[(i-1+N)%N];
      const p1 = pts[(i+1)%N];
      const u = unit(p1.x - p0.x, p1.y - p0.y);
      tang[i] = u;
      nrm[i] = {x: -u.y, y: u.x};
    }

    const startIdx = Math.floor(N * 0.02);

    // prerender to map canvas for speed
    const mapCanvas = document.createElement('canvas');
    mapCanvas.width = Math.floor(W * dpr);
    mapCanvas.height = Math.floor(H * dpr);
    const mctx = mapCanvas.getContext('2d');
    mctx.setTransform(dpr,0,0,dpr,0,0);

    renderTrackToCanvas(mctx, pts, nrm, width, startIdx, theme);

    return { pts, tang, nrm, width, startIdx, mapCanvas };
  }

  function renderTrackToCanvas(mctx, pts, nrm, width, startIdx, theme){
    mctx.clearRect(0,0,W,H);

    const laneTint = theme.lane;
    const haloCol  = theme.halo;
    const kerbA    = theme.kerbA;
    const kerbB    = theme.kerbB;

    // background
    const g = mctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, "rgba(10,16,30,0.70)");
    g.addColorStop(1, "rgba(8,10,18,0.86)");
    mctx.fillStyle = g;
    mctx.fillRect(0,0,W,H);

    // grass speckles
    mctx.save();
    mctx.globalAlpha = 0.14;
    for(let i=0;i<820;i++){
      const x = Math.random()*W;
      const y = Math.random()*H;
      const r = 1 + Math.random()*2.8;
      mctx.fillStyle = (Math.random()<0.5) ? "rgba(53,242,140,0.23)" : haloCol;
      mctx.beginPath(); mctx.arc(x,y,r,0,Math.PI*2); mctx.fill();
    }
    mctx.restore();

    // halo
    mctx.save();
    mctx.globalAlpha = 0.28;
    mctx.strokeStyle = haloCol;
    mctx.lineWidth = width + 54;
    mctx.lineCap = "round";
    mctx.beginPath();
    mctx.moveTo(pts[0].x, pts[0].y);
    for(const p of pts) mctx.lineTo(p.x,p.y);
    mctx.closePath();
    mctx.stroke();
    mctx.restore();

    // asphalt
    mctx.save();
    mctx.lineCap = "round";
    mctx.lineJoin = "round";
    mctx.strokeStyle = "rgba(10,14,26,0.96)";
    mctx.lineWidth = width;
    mctx.beginPath();
    mctx.moveTo(pts[0].x, pts[0].y);
    for(const p of pts) mctx.lineTo(p.x,p.y);
    mctx.closePath();
    mctx.stroke();
    mctx.restore();

    // lane tint
    mctx.save();
    mctx.strokeStyle = laneTint;
    mctx.lineWidth = width * 0.86;
    mctx.lineCap = "round";
    mctx.beginPath();
    mctx.moveTo(pts[0].x, pts[0].y);
    for(const p of pts) mctx.lineTo(p.x,p.y);
    mctx.closePath();
    mctx.stroke();
    mctx.restore();

    // asphalt texture
    mctx.save();
    mctx.globalAlpha = 0.14;
    for(let i=0;i<1400;i++){
      const idx = Math.floor(Math.random()*pts.length);
      const p = pts[idx];
      const nx = nrm[idx].x, ny = nrm[idx].y;
      const off = (Math.random()-0.5) * (width*0.88);
      const x = p.x + nx*off + (Math.random()-0.5)*2;
      const y = p.y + ny*off + (Math.random()-0.5)*2;
      mctx.fillStyle = (Math.random()<0.5) ? "rgba(255,255,255,0.18)" : "rgba(0,0,0,0.35)";
      mctx.fillRect(x,y,1,1);
    }
    mctx.restore();

    // kerbs
    function drawKerb(sideSign){
      mctx.save();
      mctx.globalAlpha = 0.90;
      mctx.lineCap = "butt";
      mctx.lineWidth = 9;
      for(let i=0;i<pts.length;i+=10){
        const p = pts[i];
        const nx = nrm[i].x, ny = nrm[i].y;
        const x = p.x + nx * sideSign * (width*0.52);
        const y = p.y + ny * sideSign * (width*0.52);
        const on = (Math.floor(i/10) % 2) === 0;
        mctx.strokeStyle = on ? kerbA : kerbB;
        mctx.beginPath();
        mctx.moveTo(x, y);
        const p2 = pts[(i+8)%pts.length];
        const x2 = p2.x + nrm[(i+8)%pts.length].x * sideSign * (width*0.52);
        const y2 = p2.y + nrm[(i+8)%pts.length].y * sideSign * (width*0.52);
        mctx.lineTo(x2,y2);
        mctx.stroke();
      }
      mctx.restore();
    }
    drawKerb(+1);
    drawKerb(-1);

    // center dashed
    mctx.save();
    mctx.globalAlpha = 0.55;
    mctx.lineWidth = 2;
    mctx.strokeStyle = "rgba(255,255,255,0.22)";
    for(let i=0;i<pts.length;i+=16){
      const p = pts[i];
      const p2 = pts[(i+8)%pts.length];
      mctx.beginPath();
      mctx.moveTo(p.x,p.y);
      mctx.lineTo(p2.x,p2.y);
      mctx.stroke();
    }
    mctx.restore();

    // finish line
    const i = startIdx;
    const p = pts[i];
    const t = unit(pts[(i+1)%pts.length].x - pts[(i-1+pts.length)%pts.length].x,
                   pts[(i+1)%pts.length].y - pts[(i-1+pts.length)%pts.length].y);

    const w = width*0.92;
    const h = 18;
    mctx.save();
    mctx.translate(p.x, p.y);
    mctx.rotate(Math.atan2(t.y, t.x));
    mctx.globalAlpha = 0.95;
    const cols = 12;
    for(let c=0;c<cols;c++){
      mctx.fillStyle = (c%2===0) ? "rgba(255,255,255,0.85)" : "rgba(0,0,0,0.85)";
      mctx.fillRect(-w/2 + (c/cols)*w, -h/2, w/cols, h);
    }
    mctx.strokeStyle = "rgba(90,228,255,0.25)";
    mctx.lineWidth = 2;
    mctx.strokeRect(-w/2, -h/2, w, h);
    mctx.restore();
  }

  function buildAllLapCaches(){
    for(let i=0;i<TOTAL_LAPS;i++){
      lapCache[i] = buildTrackForLap(i);
    }
  }

  // ============================================================
  // MCQ preparation (shuffle options, recompute correct index)
  // ============================================================
  function prepareQuestion(qb){
    const opts = shuffle(qb.options);
    const answer = Math.max(0, opts.indexOf(qb.correct));
    return { q: qb.q, options: opts, answer, hint: qb.hint || "", fb: qb.fb || "" };
  }
  function buildQuestionOrder(){
    const base = shuffle(QUESTIONS_BASE);
    game.qOrder = base.slice(0,TOTAL_LAPS).map(prepareQuestion);
  }

  // ============================================================
  // Overlay MCQ
  // ============================================================
  function showMCQ(){ overlay.classList.add("show"); }
  function hideMCQ(){ overlay.classList.remove("show"); }

  function lockOptions(lock){
    [...optsDiv.querySelectorAll(".opt")].forEach(el => {
      el.style.pointerEvents = lock ? "none" : "auto";
      el.style.opacity = lock ? "0.92" : "1";
    });
  }
  function mark(i, cls){
    const el = optsDiv.querySelector(`.opt[data-idx="${i}"]`);
    if(el) el.classList.add(cls);
  }

  function openMCQ(){
    game.currentQ = game.qOrder[game.lap];
    game.canAnswer = true;

    qLap.textContent = `Lap ${game.lap+1}/${TOTAL_LAPS}`;
    qText.textContent = game.currentQ.q;
    hintText.textContent = `Tip: ${game.currentQ.hint || "Choose the best answer."}`;
    fbText.textContent = "";
    optsDiv.innerHTML = "";

    const letters = ["A","B","C","D"];
    game.currentQ.options.forEach((t,i) => {
      const el = document.createElement("div");
      el.className = "opt";
      el.dataset.idx = String(i);
      el.innerHTML = `<div class="badge">${letters[i]}</div>
                      <div style="min-width:0"><div style="font-weight:760; font-size:13px; line-height:1.25">${t}</div></div>`;
      el.addEventListener("click", () => choose(i));
      optsDiv.appendChild(el);
    });

    showMCQ();
    setState(STATE.MCQ);
    beep(520, 0.06, 'triangle', 0.02);
  }

  function choose(i){
    if(game.state !== STATE.MCQ || !game.canAnswer) return;
    game.canAnswer = false;
    lockOptions(true);

    const correct = game.currentQ.answer;
    const ok = (i === correct);

    if(ok){
      mark(i,"good");
      fbText.textContent = "Correct. Next track unlocked…";
      game.feedbackNext = "advance";
      game.glow = 1.0;
      beep(760, 0.08, 'sine', 0.03);
      setState(STATE.FEED);
    } else {
      mark(i,"bad");
      mark(correct,"good");
      fbText.textContent = game.currentQ.fb || "Incorrect. Retry this lap.";
      game.feedbackNext = "retry";
      game.shake = 0.35;
      game.wrongBlink = 0.8;
      beep(220, 0.10, 'sawtooth', 0.015);
      setState(STATE.FEED);
    }
  }

  window.addEventListener("keydown", (e) => {
    if(game.state !== STATE.MCQ) return;
    const map = {a:0,b:1,c:2,d:3};
    const k = e.key.toLowerCase();
    if(map[k] !== undefined){
      e.preventDefault();
      choose(map[k]);
    }
  });

  // ============================================================
  // Particles (light)
  // ============================================================
  const particles = [];
  const MAX_PARTICLES = 90;

  function spawnParticles(x,y,n,kind){
    for(let i=0;i<n;i++){
      if(particles.length>=MAX_PARTICLES) break;
      const a = Math.random()*Math.PI*2;
      const sp = (kind==='confetti'?60:120) + Math.random()*140;
      particles.push({
        x,y,
        vx: Math.cos(a)*sp,
        vy: Math.sin(a)*sp,
        t:0,
        life: (kind==='confetti'?1.4:0.7)+Math.random()*0.35,
        kind,
        rot: Math.random()*6.28,
        vr: (Math.random()-0.5)*9,
        s: (kind==='confetti'?6:3)+Math.random()*5
      });
    }
  }
  function updateParticles(dt){
    for(let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      p.t += dt;
      const k = 1 - p.t/p.life;
      p.vy += (p.kind==='confetti'?110:200)*dt;
      p.x += p.vx*dt;
      p.y += p.vy*dt;
      p.vx *= 0.985;
      p.rot += p.vr*dt;
      if(k<=0) particles.splice(i,1);
    }
  }
  function drawParticles(){
    for(const p of particles){
      const k = Math.max(0, 1 - p.t/p.life);
      ctx.save();
      ctx.globalAlpha = 0.9*k;
      if(p.kind==='confetti'){
        ctx.translate(p.x,p.y);
        ctx.rotate(p.rot);
        ctx.fillStyle = "rgba(255,255,255,0.78)";
        ctx.fillRect(-p.s/2,-p.s/2,p.s,p.s*0.65);
      } else {
        const r = 18*p.s/8;
        const g = ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,r);
        g.addColorStop(0,"rgba(255,209,102,0.22)");
        g.addColorStop(1,"rgba(0,0,0,0)");
        ctx.fillStyle = g;
        ctx.beginPath(); ctx.arc(p.x,p.y,r,0,Math.PI*2); ctx.fill();
      }
      ctx.restore();
    }
  }

  // ============================================================
  // Car drawing
  // ============================================================
  function roundRectPath(x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
  }

  function drawCar(x,y,angle){
    ctx.save();
    ctx.translate(x,y);
    ctx.rotate(angle);

    // shadow
    ctx.globalAlpha = 0.28;
    ctx.fillStyle = "rgba(0,0,0,0.85)";
    ctx.beginPath();
    ctx.ellipse(0, 18, 20, 10, 0, 0, Math.PI*2);
    ctx.fill();

    // glow on correct
    if(game.glow>0.02){
      ctx.globalAlpha = 0.55*game.glow;
      let g = ctx.createRadialGradient(0,12,0,0,12,72);
      g.addColorStop(0,"rgba(53,242,140,0.20)");
      g.addColorStop(1,"rgba(0,0,0,0)");
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(0,12,72,0,Math.PI*2); ctx.fill();
    }

    ctx.globalAlpha = 1;
    const shell = ctx.createLinearGradient(-24,-46,24,46);
    shell.addColorStop(0, "rgba(255,77,109,0.34)");
    shell.addColorStop(0.45, "rgba(90,228,255,0.42)");
    shell.addColorStop(1, "rgba(53,242,140,0.28)");

    ctx.fillStyle = "rgba(255,255,255,0.10)";
    roundRectPath(-20,-40,40,80,16);
    ctx.fill();

    ctx.fillStyle = shell;
    roundRectPath(-17,-37,34,74,14);
    ctx.fill();

    ctx.fillStyle = "rgba(255,255,255,0.14)";
    roundRectPath(-4,-37,8,74,6);
    ctx.fill();

    ctx.fillStyle = "rgba(10,14,26,0.65)";
    roundRectPath(-12,-20,24,26,10);
    ctx.fill();

    // wheels
    ctx.fillStyle = "rgba(0,0,0,0.70)";
    roundRectPath(-21,-28,7,16,4); ctx.fill();
    roundRectPath(14,-28,7,16,4); ctx.fill();
    roundRectPath(-21,12,7,16,4); ctx.fill();
    roundRectPath(14,12,7,16,4); ctx.fill();

    // headlights
    ctx.fillStyle = "rgba(255,209,102,0.68)";
    roundRectPath(-13,-40,9,11,5); ctx.fill();
    roundRectPath(4,-40,9,11,5); ctx.fill();

    // taillights
    ctx.fillStyle = (game.wrongBlink>0) ? "rgba(255,77,109,0.88)" : "rgba(255,77,109,0.32)";
    roundRectPath(-13,29,9,11,5); ctx.fill();
    roundRectPath(4,29,9,11,5); ctx.fill();

    // rear plate
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = "rgba(255,255,255,0.10)";
    roundRectPath(-13,38,26,6,4);
    ctx.fill();

    ctx.restore();
  }

  // ============================================================
  // Main loop
  // ============================================================
  let last=0;
  function tick(ts){
    if(!last) last = ts;
    const dt = Math.min(0.033, (ts-last)/1000);
    last = ts;

    game.tState += dt;
    game.shake = Math.max(0, game.shake - dt*0.95);
    game.glow = Math.max(0, game.glow - dt*0.85);
    game.wrongBlink = Math.max(0, game.wrongBlink - dt);

    game.speed = lerp(game.speed, game.targetSpeed, 0.07);

    if(game.state === STATE.RUN){
      game.prevS = game.s;
      game.s = (game.s + game.speed*dt) % 1;

      // lap complete = wrap
      if(game.prevS > 0.92 && game.s < 0.08){
        game.targetSpeed = 0;
        openMCQ();
      }
    }

    if(game.state === STATE.FEED){
      const hold = 0.95;
      if(game.tState >= hold){
        if(game.feedbackNext === "advance"){
          hideMCQ();
          game.lap += 1;
          updateTop();

          if(game.lap >= TOTAL_LAPS){
            setState(STATE.DONE);
            game.targetSpeed = 0;
            const tr = lapCache[TOTAL_LAPS-1];
            const fp = tr.pts[tr.startIdx];
            spawnParticles(fp.x, fp.y, 40, "confetti");
            spawnParticles(fp.x+22, fp.y-10, 40, "confetti");
            beep(660, 0.10, "sine", 0.03);
          } else {
            // NEW TRACK (different geometry + theme) after correct answer
            game.s = 0.08;
            game.prevS = game.s;
            setState(STATE.RUN);
            game.targetSpeed = game.boost;
            game.glow = 1.0;
            const car = sampleTrack(game.s);
            spawnParticles(car.x, car.y, 14, "dust");
            beep(740, 0.06, "triangle", 0.02);
            game._boostT = 0.7;
          }
        } else {
          // wrong: retry same lap, same track
          hideMCQ();
          setState(STATE.RUN);
          game.targetSpeed = game.cruise;
        }
      }
    }

    if(game._boostT){
      game._boostT -= dt;
      if(game._boostT <= 0){
        game._boostT = null;
        if(game.state === STATE.RUN) game.targetSpeed = game.cruise;
      }
    }

    updateParticles(dt);
    render();
    requestAnimationFrame(tick);
  }

  function render(){
    ctx.clearRect(0,0,W,H);

    const sx = (Math.random()-0.5) * 8 * game.shake;
    const sy = (Math.random()-0.5) * 8 * game.shake;
    ctx.save();
    ctx.translate(sx,sy);

    const tr = lapCache[Math.min(game.lap, TOTAL_LAPS-1)];
    if(tr && tr.mapCanvas) ctx.drawImage(tr.mapCanvas, 0, 0, W, H);

    drawHUD();

    const car = sampleTrack(game.s);
    const ang = Math.atan2(car.ty, car.tx) + Math.PI/2;
    drawCar(car.x, car.y, ang);

    drawParticles();
    ctx.restore();
  }

  function drawHUD(){
    const pad = 14;
    const r = 16;
    const x = pad + 20;
    const y = H - pad - 30;

    ctx.save();
    ctx.globalAlpha = 0.95;
    ctx.lineWidth = 3;
    ctx.strokeStyle = "rgba(255,255,255,0.16)";
    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.stroke();

    const frac = game.s;
    ctx.strokeStyle = "rgba(90,228,255,0.55)";
    ctx.beginPath();
    ctx.arc(x,y,r, -Math.PI/2, -Math.PI/2 + Math.PI*2*frac);
    ctx.stroke();

    ctx.fillStyle = "rgba(234,240,255,0.84)";
    ctx.font = "700 12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    const lapShown = Math.min(game.lap, TOTAL_LAPS);
    ctx.fillText(`Lap ${lapShown}/${TOTAL_LAPS}`, x+28, y);

    ctx.restore();
  }

  function sampleTrack(s){
    const tr = lapCache[Math.min(game.lap, TOTAL_LAPS-1)];
    const pts = tr.pts, tang = tr.tang;
    const N = pts.length;
    const idx = Math.floor(s * N) % N;
    const p = pts[idx];
    const t = tang[idx];
    return {x:p.x, y:p.y, tx:t.x, ty:t.y, idx};
  }

  // ============================================================
  // Start / Reset
  // ============================================================
  function resetGame(){
    particles.length = 0;
    hideMCQ();

    game.lap = 0;
    game.s = 0.10;
    game.prevS = game.s;

    game.speed = 0;
    game.targetSpeed = 0;

    game.glow = 0;
    game.shake = 0;
    game.wrongBlink = 0;

    buildQuestionOrder();
    updateTop();
    setState(STATE.READY);
  }

  function startGame(){
    if(game.state === STATE.DONE) resetGame();
    if(game.state === STATE.RUN) return;
    setState(STATE.RUN);
    game.targetSpeed = game.cruise;
    const car = sampleTrack(game.s);
    spawnParticles(car.x, car.y, 10, "dust");
  }

  // ============================================================
  // Init
  // ============================================================
  function init(){
    resize();
    buildQuestionOrder();
    updateTop();
    setState(STATE.READY);
    requestAnimationFrame(tick);
  }
  init();

})();
</script>
</body>
</html>

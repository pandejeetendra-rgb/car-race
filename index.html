<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Lap Race — Cyber Security Initiatives in India (GBL)</title>
  <style>
    :root{
      --bg:#070A12;
      --panel: rgba(255,255,255,0.08);
      --panel2: rgba(255,255,255,0.12);
      --ink:#EAF0FF;
      --muted: rgba(234,240,255,0.72);
      --accent:#5AE4FF;
      --good:#35F28C;
      --bad:#FF4D6D;
      --warn:#FFD166;
      --shadow: rgba(0,0,0,0.35);
      --stroke: rgba(255,255,255,0.14);
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:
        radial-gradient(1200px 800px at 20% 10%, rgba(90,228,255,0.18), transparent 55%),
        radial-gradient(900px 600px at 80% 30%, rgba(53,242,140,0.10), transparent 60%),
        radial-gradient(1200px 800px at 50% 100%, rgba(255,209,102,0.07), transparent 55%),
        var(--bg);
      color: var(--ink);
      overflow-x:hidden;
    }
    .wrap{
      max-width: 1200px;
      margin: 0 auto;
      padding: 14px;
      display: grid;
      grid-template-columns: 1.35fr 0.65fr;
      gap: 12px;
    }
    @media (max-width: 980px){ .wrap{grid-template-columns: 1fr;} }

    .card{
      border: 1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03));
      border-radius: 18px;
      box-shadow: 0 18px 40px var(--shadow);
      overflow:hidden;
    }
    .topbar{
      display:flex; align-items:center; justify-content:space-between;
      padding: 12px 14px;
      border-bottom: 1px solid rgba(255,255,255,0.10);
      backdrop-filter: blur(6px);
      background: rgba(10,14,26,0.55);
    }
    .brand{
      display:flex; gap:10px; align-items:center;
      font-weight: 750;
      letter-spacing: 0.2px;
    }
    .dot{
      width:12px;height:12px;border-radius:50%;
      background: radial-gradient(circle at 30% 30%, #B9F6FF, #5AE4FF 50%, rgba(90,228,255,0.2));
      box-shadow: 0 0 18px rgba(90,228,255,0.55);
    }
    .meta{
      font-size: 12px; color: var(--muted);
      display:flex; gap:10px; align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .pill{
      padding: 6px 10px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      border-radius: 999px;
      display:flex; gap:8px; align-items:center;
      white-space:nowrap;
    }
    .pill b{color: var(--ink)}
    .pill .k{
      width:7px;height:7px;border-radius:50%;
      background: var(--accent);
      box-shadow: 0 0 12px rgba(90,228,255,0.6);
    }

    .stage{
      position: relative;
      aspect-ratio: 16 / 9;
      min-height: 320px;
      background:
        radial-gradient(900px 500px at 50% 50%, rgba(255,255,255,0.06), transparent 60%),
        linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.06));
    }
    canvas{ width: 100%; height: 100%; display:block; }

    .side{ padding: 12px 14px; }
    .h2{
      font-weight: 760;
      margin: 6px 0 10px;
      font-size: 14px;
      letter-spacing: 0.2px;
      color: rgba(234,240,255,0.92);
    }
    .small{ font-size: 12px; color: var(--muted); line-height: 1.45; }
    .btnrow{ display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }
    button{
      appearance:none; border: 1px solid rgba(255,255,255,0.14);
      background: linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.05));
      color: var(--ink);
      border-radius: 12px;
      padding: 10px 12px;
      font-weight: 650;
      cursor:pointer;
      box-shadow: 0 10px 24px rgba(0,0,0,0.28);
      transition: transform .12s ease, border-color .12s ease, background .12s ease;
    }
    button:hover{ transform: translateY(-1px); border-color: rgba(90,228,255,0.35); }
    button:active{ transform: translateY(0px) scale(0.99); }
    button.primary{
      border-color: rgba(90,228,255,0.45);
      background: linear-gradient(180deg, rgba(90,228,255,0.22), rgba(90,228,255,0.10));
    }
    button.ghost{ background: rgba(255,255,255,0.04); }

    .legend{ display:grid; grid-template-columns: 1fr; gap:10px; margin-top: 12px; }
    .row{
      display:flex; gap:10px; align-items:flex-start;
      padding: 10px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.04);
      border-radius: 14px;
    }
    .icon{
      width: 32px; height: 32px; border-radius: 10px;
      display:grid; place-items:center;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      flex: 0 0 auto;
    }
    .row b{display:block; font-size: 12.8px; margin-bottom: 2px;}
    .row span{display:block; font-size: 12px; color: var(--muted); line-height: 1.35;}

    /* Question overlay */
    .overlay{
      position:absolute; inset:0;
      display:none;
      align-items:center; justify-content:center;
      padding: 16px;
      background: rgba(0,0,0,0.45);
      backdrop-filter: blur(7px);
    }
    .overlay.show{ display:flex; }
    .qcard{
      width: min(860px, 100%);
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.16);
      background: linear-gradient(180deg, rgba(10,14,26,0.88), rgba(10,14,26,0.72));
      box-shadow: 0 26px 60px rgba(0,0,0,0.55);
      overflow:hidden;
    }
    .qhead{
      padding: 14px 14px 12px;
      border-bottom: 1px solid rgba(255,255,255,0.10);
      display:flex; align-items:flex-start; justify-content:space-between; gap: 10px;
    }
    .qtitle{ font-weight: 780; letter-spacing:0.2px; }
    .qmeta{ font-size: 12px; color: var(--muted); margin-top: 2px; }
    .qbody{ padding: 14px; }
    .qtext{
      font-size: 16px;
      line-height: 1.35;
      margin: 0 0 12px;
      color: rgba(234,240,255,0.95);
    }
    .opts{
      display:grid; gap:10px;
      grid-template-columns: 1fr 1fr;
    }
    @media (max-width: 640px){ .opts{ grid-template-columns: 1fr; } }
    .opt{
      text-align:left;
      padding: 12px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.05);
      cursor:pointer;
      transition: transform .12s ease, border-color .12s ease, background .12s ease;
      min-height: 54px;
      display:flex; gap:10px; align-items:flex-start;
      user-select:none;
    }
    .opt:hover{ transform: translateY(-1px); border-color: rgba(90,228,255,0.35); }
    .badge{
      width: 26px; height: 26px; border-radius: 10px;
      display:grid; place-items:center;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.06);
      font-weight: 800;
      color: rgba(234,240,255,0.92);
      flex: 0 0 auto;
    }
    .opt.good{
      border-color: rgba(53,242,140,0.55);
      background: rgba(53,242,140,0.12);
    }
    .opt.bad{
      border-color: rgba(255,77,109,0.60);
      background: rgba(255,77,109,0.10);
    }
    .qfoot{
      padding: 12px 14px;
      border-top: 1px solid rgba(255,255,255,0.10);
      display:flex; align-items:center; justify-content:space-between; gap: 10px;
      flex-wrap:wrap;
    }
    .hint{
      font-size: 12px; color: rgba(234,240,255,0.85);
      display:flex; gap:8px; align-items:center;
    }
    .hint .spark{
      width:8px;height:8px;border-radius:50%;
      background: var(--warn);
      box-shadow: 0 0 12px rgba(255,209,102,0.55);
    }
    .feedback{
      font-size: 12px; color: var(--muted);
      max-width: 70ch;
      line-height: 1.35;
    }

    /* Toast */
    .toast{
      position:absolute;
      left: 50%;
      top: 12px;
      transform: translateX(-50%) translateY(-10px);
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(10,14,26,0.72);
      box-shadow: 0 18px 45px rgba(0,0,0,0.45);
      opacity: 0;
      pointer-events:none;
      transition: opacity .18s ease, transform .18s ease;
      display:flex; gap:10px; align-items:center;
      max-width: min(760px, calc(100% - 24px));
    }
    .toast.show{ opacity:1; transform: translateX(-50%) translateY(0px); }
    .toast .chip{
      width: 10px; height: 10px; border-radius: 50%;
      background: var(--accent);
      box-shadow: 0 0 14px rgba(90,228,255,0.65);
      flex: 0 0 auto;
    }
    .toast.good .chip{ background: var(--good); box-shadow: 0 0 14px rgba(53,242,140,0.6); }
    .toast.bad .chip{ background: var(--bad); box-shadow: 0 0 14px rgba(255,77,109,0.55); }
    .toast b{ font-size: 13px; }
    .toast span{ font-size: 12px; color: var(--muted); }

    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.05);
      color: rgba(234,240,255,0.86);
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="card">
      <div class="topbar">
        <div class="brand">
          <span class="dot"></span>
          <div>
            <div>Lap Race</div>
            <div class="meta" style="justify-content:flex-start; gap:8px;">
              <span class="pill"><span class="k"></span><span>Cyber Security Initiatives in India</span></span>
              <span class="pill"><span class="k" style="background:var(--good)"></span><span>1 Lap = 1 MCQ</span></span>
            </div>
          </div>
        </div>
        <div class="meta">
          <span class="pill"><b id="lapText">Lap 0/12</b></span>
          <span class="pill"><b id="statusText">Ready</b></span>
        </div>
      </div>

      <div class="stage" id="stage">
        <canvas id="c"></canvas>

        <div class="toast" id="toast">
          <span class="chip"></span>
          <div style="min-width:0">
            <b id="toastTitle">Message</b><br/>
            <span id="toastMsg">...</span>
          </div>
        </div>

        <div class="overlay" id="overlay" aria-modal="true" role="dialog">
          <div class="qcard">
            <div class="qhead">
              <div style="min-width:0">
                <div class="qtitle" id="qTitle">Lap Question</div>
                <div class="qmeta" id="qMeta">Answer to start the next lap.</div>
              </div>
              <div class="pill"><b id="qLap">Lap 1/12</b></div>
            </div>

            <div class="qbody">
              <p class="qtext" id="qText">Question text...</p>
              <div class="opts" id="opts"></div>
            </div>

            <div class="qfoot">
              <div class="hint"><span class="spark"></span><span id="hintText">Tip…</span></div>
              <div class="feedback" id="fbText"></div>
              <div style="display:flex; gap:10px; align-items:center;">
                <span class="small">Keyboard: <span class="kbd">A</span> <span class="kbd">B</span> <span class="kbd">C</span> <span class="kbd">D</span></span>
              </div>
            </div>
          </div>
        </div>
      </div><!-- stage -->
    </div>

    <div class="card">
      <div class="side">
        <div class="h2">How to play</div>
        <div class="small">
          Drive laps automatically. At the end of each lap, a finish-line banner appears.
          When you cross it, the game pauses and shows one MCQ.
          <br/><br/>
          <b>Correct:</b> start the next lap with a speed boost.
          <br/>
          <b>Incorrect:</b> brief stall, then retry the same question.
          <br/><br/>
          No steering. No timer.
        </div>

        <div class="btnrow">
          <button class="primary" id="startBtn">Start</button>
          <button class="ghost" id="soundBtn" aria-pressed="false">Sound: Off</button>
          <button class="ghost" id="resetBtn">Reset</button>
        </div>

        <div class="legend">
          <div class="row">
            <div class="icon" title="Finish line">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none">
                <path d="M5 3v18" stroke="rgba(234,240,255,0.9)" stroke-width="2" stroke-linecap="round"/>
                <path d="M5 4h14l-3 4 3 4H5V4z" fill="rgba(255,209,102,0.55)"/>
              </svg>
            </div>
            <div>
              <b>Finish line per lap</b>
              <span>Cross it to unlock the MCQ for that lap.</span>
            </div>
          </div>

          <div class="row">
            <div class="icon" title="Learning-first">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none">
                <path d="M12 2l2.8 6.2L21.5 9l-5 4.3 1.5 6.7L12 16.8 6 20l1.5-6.7-5-4.3 6.7-.8L12 2z"
                      fill="rgba(53,242,140,0.55)"/>
              </svg>
            </div>
            <div>
              <b>Reward = momentum</b>
              <span>Correct answers give glow, sparks, and a smooth speed burst.</span>
            </div>
          </div>

          <div class="row">
            <div class="icon" title="Mobile">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none">
                <rect x="7" y="2" width="10" height="20" rx="2" stroke="rgba(234,240,255,0.9)" stroke-width="2"/>
                <circle cx="12" cy="18" r="1" fill="rgba(234,240,255,0.85)"/>
              </svg>
            </div>
            <div>
              <b>Mobile-friendly</b>
              <span>Big buttons and a clean “game → question” flow.</span>
            </div>
          </div>
        </div>

        <div class="h2" style="margin-top:14px;">Notes</div>
        <div class="small">
          This version is corrected to use <b>exactly 12 laps and exactly 12 questions</b>.
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ===========================================
  // 12-question bank (from "Cyber Security Initiatives in India")
  // ===========================================
  const QUESTIONS = [
    {
      q: "CERT-In (Computer Emergency Response Team–India) is primarily responsible for:",
      options: [
        "Responding to cyber incidents, reporting vulnerabilities, and promoting IT security practices",
        "Running state police station crime databases",
        "Issuing visas for cyber professionals",
        "Maintaining only a national email directory"
      ],
      answerIndex: 0,
      feedback: "CERT-In is the national agency for incident response, vulnerability reporting, and promoting IT security practices.",
      hint: "Think: national incident response team."
    },
    {
      q: "NISAP (National Information Security Assurance Programme) focuses mainly on:",
      options: [
        "ISO/IEC 27001-based security policy awareness and implementation support",
        "Border management and disaster response",
        "Tax intelligence database integration",
        "Replacing all security tools with open-source tools"
      ],
      answerIndex: 0,
      feedback: "NISAP supports information security policy awareness and implementation aligned with ISO/IEC 27001 / ISMS practices.",
      hint: "It is a programme tied to ISMS ideas."
    },
    {
      q: "NCTC (National Counter Terrorism Center) was proposed mainly to:",
      options: [
        "Coordinate counter-terrorism measures among state and central agencies",
        "Certify mobile phones for secure use",
        "Run cyber forensics labs in every district",
        "Issue email usage rules for universities"
      ],
      answerIndex: 0,
      feedback: "NCTC was proposed as a centralized mechanism to coordinate counter-terrorism efforts across agencies.",
      hint: "Think: counter-terrorism coordination."
    },
    {
      q: "NCIIPC is associated with protecting:",
      options: [
        "Critical Information Infrastructure (CII)",
        "Only private-sector banking passwords",
        "Only educational portals (LMS)",
        "Only social media accounts"
      ],
      answerIndex: 0,
      feedback: "NCIIPC is the nodal body for protecting Critical Information Infrastructure (CII).",
      hint: "CII protection is the keyword."
    },
    {
      q: "Which activity is listed among NCIIPC functions?",
      options: [
        "Malware analysis and tracking malware-spreading IPs",
        "Issuing driving licenses for cyber vehicles",
        "Only publishing cyber news articles",
        "Only doing annual university rankings"
      ],
      answerIndex: 0,
      feedback: "NCIIPC functions include malware analysis and tracking malware/zombie spreading IPs, alerts/advisories, forensics, etc.",
      hint: "Look for technical operations and alerts."
    },
    {
      q: "Natgrid (National Intelligence Grid) is best described as:",
      options: [
        "An integrated intelligence grid connecting databases of core security agencies",
        "A cyber awareness course for students",
        "A state-wise cybersecurity scholarship scheme",
        "A VPN service for government staff"
      ],
      answerIndex: 0,
      feedback: "Natgrid connects multiple databases of core agencies to support intelligence and investigation.",
      hint: "Think: integrated grid + databases."
    },
    {
      q: "CCTNS (Crime and Criminal Tracking Network & Systems) mainly aims to:",
      options: [
        "Network police stations and enable crime/criminal tracking across locations",
        "Replace CERT-In operations",
        "Provide only cyber awareness posters",
        "Publish ISO standards for networks"
      ],
      answerIndex: 0,
      feedback: "CCTNS links police stations and supports tracking of crime and criminals across regions.",
      hint: "Think: police network + crime tracking."
    },
    {
      q: "NCCC (National Cyber Coordination Centre) is intended primarily for:",
      options: [
        "Cyber coordination and monitoring, including metadata screening and intelligence support",
        "Only academic curriculum approval",
        "Only software licensing management",
        "Only online examination scheduling"
      ],
      answerIndex: 0,
      feedback: "NCCC is described as a cyber coordination/monitoring setup for cyber security and e-surveillance style functions.",
      hint: "Think: coordination + monitoring."
    },
    {
      q: "A Botnet Cleaning Center is meant to:",
      options: [
        "Detect botnets/malware and help users remove them from infected devices",
        "Provide email accounts to all citizens",
        "Replace police investigation systems",
        "Issue passports for IT professionals"
      ],
      answerIndex: 0,
      feedback: "The Botnet Cleaning Center supports detection and removal of botnets/malware from devices.",
      hint: "Think: cleaning infected devices."
    },
    {
      q: "Indo–US Cyber Security Forum (IUSCSF) was created mainly to:",
      options: [
        "Support India–US cooperation and dialogue on cyber security issues",
        "Maintain India’s national crime records",
        "Operate CCTNS networks",
        "Issue ISO certificates for companies"
      ],
      answerIndex: 0,
      feedback: "IUSCSF is intended to strengthen cooperation and dialogue between India and the US on cyber security.",
      hint: "Think: bilateral cooperation forum."
    },
    {
      q: "The Government of India e-mail policy is mainly about:",
      options: [
        "Guidelines and safe practices for official e-mail usage",
        "Replacing all internet connections with intranet",
        "Banning password use in government",
        "Forcing only one email provider for the private sector"
      ],
      answerIndex: 0,
      feedback: "Email policy focuses on secure and appropriate usage guidelines for official communication.",
      hint: "Think: usage policy and safe practice."
    },
    {
      q: "DSCI (Data Security Council of India) is best described as:",
      options: [
        "An industry body promoting data security and privacy culture in India",
        "A police station networking project",
        "A counter-terrorism intelligence grid",
        "A malware cleaning tool"
      ],
      answerIndex: 0,
      feedback: "DSCI is an industry-led body that works to strengthen data security and privacy practices.",
      hint: "Think: industry body + data security."
    }
  ];

  // =============================
  // Config
  // =============================
  const TOTAL_LAPS = 12;
  const FINISH_AHEAD = 640; // how far the finish line spawns in front of the car (world units)

  const canvas = document.getElementById('c');
  const stage = document.getElementById('stage');
  const ctx = canvas.getContext('2d');

  function resize(){
    const r = stage.getBoundingClientRect();
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    canvas.width = Math.floor(r.width * dpr);
    canvas.height = Math.floor(r.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', resize);

  // UI
  const overlay = document.getElementById('overlay');
  const optsDiv = document.getElementById('opts');
  const qText = document.getElementById('qText');
  const qTitle = document.getElementById('qTitle');
  const qMeta = document.getElementById('qMeta');
  const qLap = document.getElementById('qLap');
  const fbText = document.getElementById('fbText');
  const hintText = document.getElementById('hintText');
  const lapText = document.getElementById('lapText');
  const statusText = document.getElementById('statusText');
  const startBtn = document.getElementById('startBtn');
  const resetBtn = document.getElementById('resetBtn');
  const soundBtn = document.getElementById('soundBtn');
  const toast = document.getElementById('toast');
  const toastTitle = document.getElementById('toastTitle');
  const toastMsg = document.getElementById('toastMsg');

  // Sound
  let soundOn = false;
  let audioCtx = null;
  function beep(freq=440, dur=0.08, type='sine', gain=0.03){
    if(!soundOn) return;
    if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const t0 = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type; o.frequency.value = freq;
    g.gain.setValueAtTime(gain, t0);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
    o.connect(g).connect(audioCtx.destination);
    o.start(t0);
    o.stop(t0 + dur);
  }

  // Helpers
  function lerp(a,b,t){ return a + (b-a)*t; }
  function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }

  function shuffle(arr){
    const a = arr.slice();
    for(let i=a.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  // =============================
  // World + path
  // =============================
  const path = [];
  const world = { y: 0 };
  const road = { width: 270 };

  function buildPath(){
    path.length = 0;
    const w = stage.getBoundingClientRect().width;
    const h = stage.getBoundingClientRect().height;

    const centerX = w * 0.5;
    const startY = h + 280;
    const endY = -1600;

    const segments = 100;
    for(let i=0;i<=segments;i++){
      const t = i / segments;
      const x = centerX
        + Math.sin(t* Math.PI * 2.2) * 128
        + Math.sin(t* Math.PI * 5.1) * 34
        + (t - 0.5) * 52;
      const y = startY + (endY - startY)*t;
      path.push({x,y});
    }
  }

  function nearestPathIndexForY(targetY){
    let bestI = 0, bestD = Infinity;
    for(let i=0;i<path.length;i++){
      const d = Math.abs(path[i].y - targetY);
      if(d < bestD){ bestD = d; bestI = i; }
    }
    return bestI;
  }

  // =============================
  // Particles + roadside
  // =============================
  const particles = [];
  function spawnParticles(x,y, count, kind){
    for(let i=0;i<count;i++){
      const a = Math.random()*Math.PI*2;
      const sp = (kind==='confetti' ? 70 : 110) + Math.random()*140;
      const vx = Math.cos(a)*sp + (Math.random()-0.5)*28;
      const vy = Math.sin(a)*sp - (kind==='dust' ? 60 : 0);
      particles.push({ x,y, vx,vy, life:(kind==='confetti'?1.35:0.70)+Math.random()*0.45, t:0, kind, rot:Math.random()*6.28, vr:(Math.random()-0.5)*9, s:(kind==='confetti'?6:3)+Math.random()*5 });
    }
  }
  function updateParticles(dt){
    for(let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      p.t += dt;
      const k = Math.max(0, 1 - p.t/p.life);
      p.vy += (p.kind==='confetti' ? 120 : 180) * dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.rot += p.vr * dt;
      p.vx *= 0.985;
      if(k<=0) particles.splice(i,1);
    }
  }

  const roadsideLabels = [
    "CERT-In", "NISAP", "NCIIPC", "Natgrid", "CCTNS", "NCCC",
    "IUSCSF", "Email Policy", "Botnet Cleaning", "NCTC", "DSCI", "NCRB"
  ];

  // =============================
  // State
  // =============================
  const STATE = { READY:'ready', RUNNING:'running', QUESTION:'question', FEEDBACK:'feedback', FINISHED:'finished', STALL:'stall' };

  const game = {
    state: STATE.READY,
    lapIndex: 0,
    questionsRun: [],
    currentQ: null,
    attemptsAtLap: 0,
    timeInState: 0,
    shake: 0,
    speed: 0,
    targetSpeed: 0,
    car: { x:0, y:0, tilt:0, glow:0, trail:[] },
    finish: { x:0, y:0, active:false }, // one finish line per lap
    tuning: { cruise: 235, burst: 340, stallTime: 1.2, preQuestionPause: 0.55, postAnswerHold: 0.95, triggerRadius: 36 }
  };

  function setState(s){
    game.state = s;
    game.timeInState = 0;
    statusText.textContent =
      s===STATE.READY ? "Ready" :
      s===STATE.RUNNING ? "Racing" :
      s===STATE.QUESTION ? "Question" :
      s===STATE.STALL ? "Paused" :
      s===STATE.FEEDBACK ? "Feedback" :
      s===STATE.FINISHED ? "Finished" : s;
  }

  // Toast
  let toastTimer = 0;
  function showToast(type, title, msg){
    toast.classList.remove('good','bad');
    if(type==='good') toast.classList.add('good');
    if(type==='bad') toast.classList.add('bad');
    toastTitle.textContent = title;
    toastMsg.textContent = msg;
    toast.classList.add('show');
    toastTimer = 2.2;
  }

  // =============================
  // Finish line (lap gate) logic
  // =============================
  function spawnFinishLineAhead(){
    const h = stage.getBoundingClientRect().height;
    const carScreenY = h * 0.72;
    const carWorldY = carScreenY - world.y;

    const targetWorldY = carWorldY - FINISH_AHEAD; // ahead of the car (above)
    const idx = nearestPathIndexForY(targetWorldY);
    const p = path[idx];

    game.finish.x = p.x;
    game.finish.y = p.y;
    game.finish.active = true;
  }

  // =============================
  // Questions
  // =============================
  function openQuestion(lapIdx){
    game.currentQ = game.questionsRun[lapIdx];
    game.attemptsAtLap = 0;

    qTitle.textContent = "Lap Question";
    qMeta.textContent = "No timer. Answer to start the next lap.";
    qLap.textContent = `Lap ${lapIdx+1}/${TOTAL_LAPS}`;
    qText.textContent = game.currentQ.q;
    fbText.textContent = "";
    hintText.textContent = `Tip: ${game.currentQ.hint || "Choose the best answer."}`;

    optsDiv.innerHTML = "";
    const letters = ["A","B","C","D"];
    game.currentQ.options.forEach((optText, i) => {
      const d = document.createElement('div');
      d.className = 'opt';
      d.dataset.idx = String(i);
      d.innerHTML = `<div class="badge">${letters[i]}</div><div style="min-width:0"><div style="font-weight:700; font-size:13px; line-height:1.25">${optText}</div></div>`;
      d.addEventListener('click', () => chooseOption(i));
      optsDiv.appendChild(d);
    });

    overlay.classList.add('show');
    setState(STATE.QUESTION);
    beep(520, 0.06, 'triangle', 0.02);
  }

  function closeQuestion(){ overlay.classList.remove('show'); }

  function lockOptions(lock=true){
    [...optsDiv.querySelectorAll('.opt')].forEach(el => {
      el.style.pointerEvents = lock ? 'none' : 'auto';
      el.style.opacity = lock ? '0.92' : '1';
    });
  }

  function markOption(idx, cls){
    const el = optsDiv.querySelector(`.opt[data-idx="${idx}"]`);
    if(el) el.classList.add(cls);
  }

  function chooseOption(idx){
    if(game.state !== STATE.QUESTION) return;
    lockOptions(true);
    game.attemptsAtLap += 1;

    const correctIdx = game.currentQ.answerIndex;
    const correct = idx === correctIdx;

    if(correct){
      markOption(idx,'good');
      fbText.textContent = "Correct. Starting the next lap.";
      beep(760, 0.08, 'sine', 0.03);
      game.car.glow = 1.0;
      spawnParticles(game.car.x, game.car.y+20, 20, 'dust');
      setState(STATE.FEEDBACK);
      game._feedbackNext = 'advance';
    } else {
      markOption(idx,'bad');
      markOption(correctIdx,'good');
      game.shake = 0.38;
      fbText.textContent = (game.currentQ.feedback || "Incorrect. Review and try again.");
      beep(220, 0.10, 'sawtooth', 0.015);
      setState(STATE.FEEDBACK);
      game._feedbackNext = 'retry';
    }
  }

  window.addEventListener('keydown', (e) => {
    if(game.state !== STATE.QUESTION) return;
    const map = {a:0,b:1,c:2,d:3};
    const k = e.key.toLowerCase();
    if(map[k] !== undefined){ e.preventDefault(); chooseOption(map[k]); }
  });

  // =============================
  // Start/reset
  // =============================
  function resetGame(){
    closeQuestion();
    particles.length = 0;
    game.car.trail = [];
    game.lapIndex = 0;
    game.speed = 0;
    game.targetSpeed = 0;
    world.y = 0;
    game.shake = 0;
    game.car.glow = 0;
    game.finish.active = false;

    // exactly 12 questions for 12 laps
    game.questionsRun = shuffle(QUESTIONS).slice(0, TOTAL_LAPS);

    lapText.textContent = `Lap 0/${TOTAL_LAPS}`;
    spawnFinishLineAhead();

    showToast('good', 'Ready', 'Press Start. Finish line will unlock the first MCQ at lap end.');
    setState(STATE.READY);
  }

  function startGame(){
    if(game.state === STATE.FINISHED) resetGame();
    if(game.state === STATE.RUNNING) return;
    showToast('good', 'Go', 'Complete the lap. Cross the finish line to unlock the MCQ.');
    setState(STATE.RUNNING);
    game.targetSpeed = game.tuning.cruise;
  }

  document.getElementById('startBtn').addEventListener('click', startGame);
  document.getElementById('resetBtn').addEventListener('click', resetGame);
  document.getElementById('soundBtn').addEventListener('click', async () => {
    soundOn = !soundOn;
    soundBtn.textContent = `Sound: ${soundOn ? "On" : "Off"}`;
    soundBtn.setAttribute('aria-pressed', soundOn ? "true" : "false");
    if(soundOn){
      try{
        if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if(audioCtx.state === "suspended") await audioCtx.resume();
        beep(600, 0.05, 'triangle', 0.02);
      }catch(_){}
    }
  });

  // =============================
  // Drawing helpers
  // =============================
  function roundRect(ctx, x, y, w, h, r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
  }

  function drawGlowCircle(x,y,r, color, alpha){
    ctx.save();
    ctx.globalAlpha = alpha;
    const g = ctx.createRadialGradient(x,y,0,x,y,r);
    g.addColorStop(0, color);
    g.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = g;
    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }

  // =============================
  // Road + visuals
  // =============================
  let perfTime = 0;

  function drawBackgroundStreaks(w,h){
    // subtle speed streaks, low distraction
    ctx.save();
    const n = 18;
    ctx.globalAlpha = 0.10;
    for(let i=0;i<n;i++){
      const x = (i*71 % Math.floor(w)) + (Math.sin(perfTime*0.7+i)*18);
      const y = (i*121 % Math.floor(h)) + ((world.y*0.12) % 80);
      ctx.strokeStyle = 'rgba(90,228,255,0.25)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x+10, y+30);
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawRoad(){
    const w = stage.getBoundingClientRect().width;
    const h = stage.getBoundingClientRect().height;

    drawBackgroundStreaks(w,h);

    const left = [];
    const right = [];
    const margin = 260;
    const yMin = -margin;
    const yMax = h + margin;

    for(let i=0;i<path.length;i++){
      const p = path[i];
      const sy = p.y + world.y;
      if(sy < yMin || sy > yMax) continue;

      const p2 = path[Math.min(path.length-1, i+1)];
      const dx = p2.x - p.x;
      const dy = p2.y - p.y;
      const len = Math.hypot(dx,dy) || 1;
      const nx = -dy/len;
      const ny = dx/len;

      const half = road.width/2;
      left.push({ x: p.x + nx*half, y: sy + ny*half });
      right.push({ x: p.x - nx*half, y: sy - ny*half });
    }

    if(left.length > 2){
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(left[0].x, left[0].y);
      for(const a of left) ctx.lineTo(a.x,a.y);
      for(let i=right.length-1;i>=0;i--) ctx.lineTo(right[i].x, right[i].y);
      ctx.closePath();

      const g = ctx.createLinearGradient(0,0,0,h);
      g.addColorStop(0, 'rgba(18,22,40,0.92)');
      g.addColorStop(0.55, 'rgba(10,14,26,0.94)');
      g.addColorStop(1, 'rgba(8,10,18,0.98)');
      ctx.fillStyle = g;
      ctx.fill();

      // road edges glow
      ctx.globalAlpha = 0.58;
      ctx.strokeStyle = 'rgba(90,228,255,0.20)';
      ctx.lineWidth = 5;
      ctx.beginPath(); ctx.moveTo(left[0].x, left[0].y);
      for(const a of left) ctx.lineTo(a.x,a.y);
      ctx.stroke();

      ctx.strokeStyle = 'rgba(53,242,140,0.14)';
      ctx.lineWidth = 4;
      ctx.beginPath(); ctx.moveTo(right[0].x, right[0].y);
      for(const a of right) ctx.lineTo(a.x,a.y);
      ctx.stroke();

      // center dashed line
      ctx.globalAlpha = 0.60;
      ctx.strokeStyle = 'rgba(255,255,255,0.22)';
      ctx.lineWidth = 2;
      for(let i=1;i<path.length;i++){
        const a = {x:path[i-1].x, y:path[i-1].y + world.y};
        const b = {x:path[i].x, y:path[i].y + world.y};
        if(a.y < yMin || a.y > yMax) continue;
        const toggle = Math.floor((a.y + world.y*0.03) / 26) % 2;
        if(toggle===0){
          ctx.beginPath();
          ctx.moveTo(a.x,a.y);
          ctx.lineTo(b.x,b.y);
          ctx.stroke();
        }
      }

      ctx.restore();
    }

    // roadside micro signs (purely visual)
    ctx.save();
    const labelEvery = 160;
    for(let i=0;i<12;i++){
      const yy = (h + 140) - ((world.y*0.8 + i*labelEvery) % (h + 280));
      const side = (i%2===0) ? -1 : 1;
      const x = (w*0.5) + side*(road.width*0.62 + 55);
      const pulse = 0.55 + 0.45*Math.sin(perfTime*1.6 + i);

      drawGlowCircle(x, yy, 26, 'rgba(90,228,255,0.14)', 0.55*pulse);

      ctx.globalAlpha = 0.9;
      ctx.fillStyle = 'rgba(255,255,255,0.07)';
      roundRect(ctx, x-50, yy-16, 100, 32, 10);
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,0.12)';
      ctx.lineWidth = 1;
      ctx.stroke();

      ctx.fillStyle = 'rgba(234,240,255,0.84)';
      ctx.font = '800 11px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(roadsideLabels[i], x, yy+0.5);
    }
    ctx.restore();
  }

  function drawFinishLine(){
    if(!game.finish.active) return;

    const h = stage.getBoundingClientRect().height;
    const x = game.finish.x;
    const y = game.finish.y + world.y;

    if(y < -220 || y > h + 220) return;

    const w = road.width * 0.90;

    ctx.save();
    const pulse = 0.55 + 0.45*Math.sin(perfTime*2.0);
    drawGlowCircle(x, y, 150, 'rgba(255,209,102,0.18)', 0.85*pulse);
    drawGlowCircle(x, y, 110, 'rgba(90,228,255,0.12)', 0.75*pulse);

    // stripes
    const stripes = 14;
    const stripeW = w / stripes;
    const y0 = y - 12, hh = 24;
    for(let i=0;i<stripes;i++){
      ctx.fillStyle = (i%2===0) ? 'rgba(255,255,255,0.78)' : 'rgba(10,14,26,0.88)';
      ctx.fillRect(x - w/2 + i*stripeW, y0, stripeW, hh);
    }
    ctx.strokeStyle = 'rgba(255,255,255,0.22)';
    ctx.lineWidth = 2;
    ctx.strokeRect(x - w/2, y0, w, hh);

    // banner
    ctx.globalAlpha = 0.95;
    ctx.fillStyle = 'rgba(255,255,255,0.08)';
    roundRect(ctx, x - 82, y0 - 34, 164, 22, 10);
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,209,102,0.28)';
    ctx.stroke();

    ctx.fillStyle = 'rgba(234,240,255,0.92)';
    ctx.font = '900 12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.textAlign='center';
    ctx.textBaseline='middle';
    ctx.fillText('FINISH LINE', x, y0 - 23);

    ctx.restore();
  }

  function getPathPointByY(targetWorldY){
    const idx = nearestPathIndexForY(targetWorldY);
    return { p: path[idx], idx };
  }

  // =============================
  // Car (more attractive)
  // =============================
  function drawCar(){
    const w = stage.getBoundingClientRect().width;
    const h = stage.getBoundingClientRect().height;

    const carScreenY = h * 0.72;
    const carWorldY = carScreenY - world.y;

    const { p, idx } = getPathPointByY(carWorldY);
    const p2 = path[Math.min(path.length-1, idx+1)];

    game.car.x = p.x;
    game.car.y = carScreenY;

    const dx = p2.x - p.x;
    const dy = p2.y - p.y;
    const tilt = clamp((dx / (Math.abs(dy)+1)) * 0.7, -0.55, 0.55);
    game.car.tilt = lerp(game.car.tilt, tilt, 0.12);

    // trail
    game.car.trail.push({x:game.car.x, y:game.car.y, t:0});
    if(game.car.trail.length > 22) game.car.trail.shift();

    ctx.save();
    for(let i=0;i<game.car.trail.length;i++){
      const tr = game.car.trail[i];
      const a = i / game.car.trail.length;
      ctx.globalAlpha = 0.16 * a;
      drawGlowCircle(tr.x, tr.y+18, 28, 'rgba(90,228,255,0.40)', 0.7*a);
      drawGlowCircle(tr.x, tr.y+18, 22, 'rgba(255,77,109,0.14)', 0.55*a);
    }
    ctx.restore();

    // shadow
    ctx.save();
    ctx.globalAlpha = 0.35;
    ctx.beginPath();
    ctx.ellipse(game.car.x, game.car.y+24, 28, 12, 0, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(0,0,0,0.70)';
    ctx.fill();
    ctx.restore();

    // glow
    if(game.car.glow > 0.01){
      drawGlowCircle(game.car.x, game.car.y+6, 92, 'rgba(53,242,140,0.30)', 0.7*game.car.glow);
      drawGlowCircle(game.car.x, game.car.y+6, 70, 'rgba(90,228,255,0.16)', 0.6*game.car.glow);
    }

    // body
    ctx.save();
    ctx.translate(game.car.x, game.car.y);
    ctx.rotate(game.car.tilt * 0.30);

    // outer shell
    const shell = ctx.createLinearGradient(-22,-36,22,36);
    shell.addColorStop(0, 'rgba(255,255,255,0.10)');
    shell.addColorStop(0.35, 'rgba(90,228,255,0.28)');
    shell.addColorStop(0.7, 'rgba(255,77,109,0.14)');
    shell.addColorStop(1, 'rgba(255,255,255,0.07)');

    // inner neon paint (more colorful)
    const paint = ctx.createLinearGradient(-20,-34,20,34);
    paint.addColorStop(0, 'rgba(255,77,109,0.25)');  // pink/red
    paint.addColorStop(0.45, 'rgba(90,228,255,0.33)'); // cyan
    paint.addColorStop(1, 'rgba(53,242,140,0.22)'); // green

    // chassis
    ctx.fillStyle = 'rgba(255,255,255,0.10)';
    roundRect(ctx, -21, -36, 42, 72, 16);
    ctx.fill();

    ctx.fillStyle = shell;
    roundRect(ctx, -19, -34, 38, 68, 15);
    ctx.fill();

    // paint layer
    ctx.globalAlpha = 0.95;
    ctx.fillStyle = paint;
    roundRect(ctx, -17, -32, 34, 64, 14);
    ctx.fill();

    // window
    ctx.globalAlpha = 0.92;
    ctx.fillStyle = 'rgba(10,14,26,0.62)';
    roundRect(ctx, -12, -18, 24, 22, 10);
    ctx.fill();

    // center stripe
    ctx.globalAlpha = 0.90;
    ctx.fillStyle = 'rgba(255,255,255,0.14)';
    roundRect(ctx, -4, -32, 8, 64, 6);
    ctx.fill();

    // side fins
    ctx.globalAlpha = 0.75;
    ctx.fillStyle = 'rgba(90,228,255,0.12)';
    roundRect(ctx, -19, -10, 6, 30, 6);
    roundRect(ctx, 13, -10, 6, 30, 6);
    ctx.fill();

    // headlights
    ctx.globalAlpha = 0.92;
    ctx.fillStyle = 'rgba(255,209,102,0.60)';
    roundRect(ctx, -15, -36, 9, 11, 6);
    roundRect(ctx, 6, -36, 9, 11, 6);
    ctx.fill();

    // brake lights
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = (game._lastWrongBlink>0) ? 'rgba(255,77,109,0.88)' : 'rgba(255,77,109,0.28)';
    roundRect(ctx, -15, 25, 9, 11, 6);
    roundRect(ctx, 6, 25, 9, 11, 6);
    ctx.fill();

    // neon underglow
    ctx.globalAlpha = 0.75;
    drawGlowCircle(0, 18, 42, 'rgba(90,228,255,0.24)', 0.9);
    drawGlowCircle(0, 18, 34, 'rgba(255,77,109,0.12)', 0.8);

    ctx.restore();
  }

  function drawParticles(){
    for(const p of particles){
      const k = Math.max(0, 1 - p.t/p.life);
      ctx.save();
      ctx.globalAlpha = 0.90 * k;
      if(p.kind === 'confetti'){
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rot);
        ctx.fillStyle = 'rgba(255,255,255,0.78)';
        ctx.fillRect(-p.s/2, -p.s/2, p.s, p.s*0.65);
        ctx.restore();
      } else {
        drawGlowCircle(p.x, p.y, 20*p.s/8, 'rgba(255,209,102,0.22)', 0.42*k);
        drawGlowCircle(p.x, p.y, 14*p.s/8, 'rgba(90,228,255,0.22)', 0.35*k);
        ctx.restore();
      }
    }
  }

  function drawProgressHUD(){
    const w = stage.getBoundingClientRect().width;
    const h = stage.getBoundingClientRect().height;
    const pad = 14;
    const barW = Math.min(540, w - 2*pad);
    const barH = 10;
    const x = pad;
    const y = h - pad - barH - 6;

    const frac = clamp(game.lapIndex / TOTAL_LAPS, 0, 1);

    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    roundRect(ctx, x, y, barW, barH, 8);
    ctx.fill();

    const g = ctx.createLinearGradient(x,y,x+barW,y);
    g.addColorStop(0, 'rgba(255,77,109,0.45)');
    g.addColorStop(0.5, 'rgba(90,228,255,0.55)');
    g.addColorStop(1, 'rgba(53,242,140,0.45)');
    ctx.fillStyle = g;
    roundRect(ctx, x, y, barW*frac, barH, 8);
    ctx.fill();

    for(let i=0;i<TOTAL_LAPS;i++){
      const t = i/(TOTAL_LAPS-1);
      const cx = x + t*barW;
      const cy = y + barH/2;
      const done = (i < game.lapIndex);
      const active = (i === game.lapIndex);
      if(active) drawGlowCircle(cx, cy, 18, 'rgba(255,209,102,0.22)', 0.85);
      ctx.beginPath();
      ctx.arc(cx, cy, 3.2, 0, Math.PI*2);
      ctx.fillStyle = done ? 'rgba(53,242,140,0.85)' : active ? 'rgba(255,209,102,0.85)' : 'rgba(234,240,255,0.35)';
      ctx.fill();
    }

    ctx.fillStyle = 'rgba(234,240,255,0.84)';
    ctx.font = '700 12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'bottom';
    ctx.fillText(`Progress: ${game.lapIndex}/${TOTAL_LAPS} laps`, x, y - 6);
    ctx.restore();
  }

  // =============================
  // Loop
  // =============================
  let last = 0;

  function update(dt){
    perfTime += dt;

    if(toastTimer > 0){
      toastTimer -= dt;
      if(toastTimer <= 0) toast.classList.remove('show');
    }

    game.shake = Math.max(0, game.shake - dt*0.95);
    game.car.glow = Math.max(0, game.car.glow - dt*0.85);
    game._lastWrongBlink = Math.max(0, (game._lastWrongBlink||0) - dt);

    game.speed = lerp(game.speed, game.targetSpeed, 0.06);
    game.timeInState += dt;

    if(game.state === STATE.RUNNING){
      world.y += game.speed * dt;

      // detect finish-line crossing
      if(game.finish.active){
        const finishY = game.finish.y + world.y; // screen y of finish line
        const d = Math.abs(game.car.y - finishY);
        if(d < game.tuning.triggerRadius){
          // lap completed -> pause -> MCQ
          game.targetSpeed = 0;
          setState(STATE.STALL);
          game._stallReason = 'preQuestion';
          showToast(null, 'Lap completed', `Lap ${game.lapIndex+1}: answer the MCQ to start next lap.`);
          beep(480, 0.06, 'triangle', 0.02);
        }
      }
    }

    if(game.state === STATE.STALL){
      if(game._stallReason === 'preQuestion'){
        if(game.timeInState >= game.tuning.preQuestionPause){
          openQuestion(game.lapIndex);
          game._stallReason = null;
        }
      } else if(game._stallReason === 'wrongAnswer'){
        if(game.timeInState >= game.tuning.stallTime){
          openQuestion(game.lapIndex);
          game._stallReason = null;
        }
      }
    }

    if(game.state === STATE.FEEDBACK){
      if(game.timeInState >= game.tuning.postAnswerHold){
        if(game._feedbackNext === 'advance'){
          closeQuestion();

          // mark lap done
          game.lapIndex += 1;
          lapText.textContent = `Lap ${game.lapIndex}/${TOTAL_LAPS}`;

          if(game.lapIndex >= TOTAL_LAPS){
            setState(STATE.FINISHED);
            game.targetSpeed = 0;
            showToast('good', 'Finished', 'All laps completed. Great job!');
            for(let i=0;i<5;i++){
              spawnParticles(game.car.x + (Math.random()-0.5)*70, game.car.y-60, 24, 'confetti');
            }
            beep(660, 0.09, 'sine', 0.03);
            game.finish.active = false;
          } else {
            // spawn next lap finish line ahead
            spawnFinishLineAhead();
            setState(STATE.RUNNING);
            game.targetSpeed = game.tuning.burst;
            game._burstTimer = 0.6;
            showToast('good', 'Next lap', `Lap ${game.lapIndex+1} started. Reach the finish line.`);
          }
        } else {
          closeQuestion();
          setState(STATE.STALL);
          game._stallReason = 'wrongAnswer';
          game._lastWrongBlink = 0.65;
          showToast('bad', 'Try again', 'Reattempt the same lap question.');
        }
      }
    }

    if(game._burstTimer){
      game._burstTimer -= dt;
      if(game._burstTimer <= 0){
        game._burstTimer = null;
        if(game.state === STATE.RUNNING) game.targetSpeed = game.tuning.cruise;
      }
    }

    updateParticles(dt);
  }

  function render(){
    const w = stage.getBoundingClientRect().width;
    const h = stage.getBoundingClientRect().height;

    const sx = (Math.random()-0.5) * 8 * game.shake;
    const sy = (Math.random()-0.5) * 8 * game.shake;

    ctx.save();
    ctx.clearRect(0,0,w,h);
    ctx.translate(sx, sy);

    drawRoad();
    drawFinishLine();
    drawCar();
    drawParticles();
    drawProgressHUD();

    ctx.restore();
  }

  function loop(ts){
    if(!last) last = ts;
    const dt = Math.min(0.033, (ts - last) / 1000);
    last = ts;
    update(dt);
    render();
    requestAnimationFrame(loop);
  }

  // Init
  function init(){
    resize();
    buildPath();
    resetGame();
    requestAnimationFrame(loop);
  }

  // Rebuild on large size change
  let lastW = 0, lastH = 0;
  setInterval(() => {
    const r = stage.getBoundingClientRect();
    const w = Math.round(r.width), h = Math.round(r.height);
    if(Math.abs(w-lastW) > 40 || Math.abs(h-lastH) > 40){
      lastW = w; lastH = h;
      buildPath();
      spawnFinishLineAhead();
    }
  }, 600);

  init();
})();
</script>
</body>
</html>
